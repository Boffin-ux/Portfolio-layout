(()=>{"use strict";var __webpack_modules__={240:()=>{eval("\n;// CONCATENATED MODULE: ./src/modules/accordeon.js\nconst accordeon = () => {\r\n   const featureList = document.querySelector('.feature-list');\r\n   const featureLinks = document.querySelectorAll('.feature__link');\r\n   const featureSubs = document.querySelectorAll('.feature-sub');\r\n\r\n   const activeItem = e => {\r\n      e.preventDefault();\r\n      const target = e.target;\r\n      if (target.closest('.feature__link') && !target.closest('.feature__link_active')) {\r\n         const getParent = target.closest('.feature__link').parentNode;\r\n         const getLink = getParent.querySelector('.feature__link');\r\n         const getSub = getParent.querySelector('.feature-sub');\r\n         featureLinks.forEach(item => item.classList.remove('feature__link_active'));\r\n         featureSubs.forEach(item => item.classList.add('hidden'));\r\n         getLink.classList.add('feature__link_active');\r\n         getSub.classList.remove('hidden');\r\n      }\r\n   };\r\n\r\n   featureList.addEventListener('click', activeItem);\r\n};\r\n\r\n/* harmony default export */ const modules_accordeon = (accordeon);\n;// CONCATENATED MODULE: ./src/modules/countTimer.js\nconst countTimer = deadline => {\r\n\r\n   const getTimer = document.querySelector('.timer__time');\r\n\r\n   const getTimeRemaining = () => {\r\n      const dateStop = new Date(deadline),\r\n         dateNow = new Date().getTime(),\r\n         timerRemaining = (dateStop - dateNow) / 1000,\r\n         seconds = Math.floor(timerRemaining % 60),\r\n         minutes = Math.floor((timerRemaining / 60) % 60),\r\n         hours = Math.floor(timerRemaining / 60 / 60);\r\n      return { timerRemaining, hours, minutes, seconds };\r\n   };\r\n   const addZero = num => {\r\n      if (num >= 0 && num <= 9) {\r\n         return `0${num}`;\r\n      } else {\r\n         return num;\r\n      }\r\n   };\r\n   const updateClock = () => {\r\n      const timer = getTimeRemaining();\r\n      if (timer.timerRemaining > 0) {\r\n         getTimer.innerHTML = `${addZero(timer.hours)}:${addZero(timer.minutes)}:${addZero(timer.seconds)}`;\r\n      } else {\r\n         getTimer.textContent = `${'00:00:00'}`;\r\n         clearInterval(idInterval);\r\n      }\r\n   };\r\n   const idInterval = setInterval(updateClock, 1000);\r\n   updateClock();\r\n};\r\n\r\n/* harmony default export */ const modules_countTimer = (countTimer);\r\n\n;// CONCATENATED MODULE: ./src/modules/menu.js\nconst menu = () => {\r\n   const humburgerMenu = document.querySelector('.humburger-menu');\r\n   const menu = document.querySelector('.menu');\r\n\r\n   const openMenu = () => {\r\n      menu.style.top = '0';\r\n      document.addEventListener('click', closeMenu);\r\n   };\r\n   const closeMenu = e => {\r\n      if (!e.target.closest('.menu-list') && !e.target.closest('.humburger-menu') || e.target.closest('.menu-list__item')) {\r\n         menu.style.top = '-300px';\r\n         document.removeEventListener('click', closeMenu);\r\n      }\r\n   };\r\n   humburgerMenu.addEventListener('click', openMenu);\r\n};\r\n\r\n/* harmony default export */ const modules_menu = (menu);\n;// CONCATENATED MODULE: ./src/modules/blockScrolled.js\nconst disableScroll = () => {\r\n   document.body.dataset.scrollY = window.scrollY;\r\n\r\n   const scrollWidth = window.innerWidth - document.body.offsetWidth;\r\n\r\n   document.body.style.cssText = `\r\n      position: fixed;\r\n      top: -${window.scrollY}px;\r\n      left: 0;\r\n      width: 100%;\r\n      overflow: hidden;\r\n      height: 100vh;\r\n      padding-right: ${scrollWidth}px;\r\n   `;\r\n};\r\nconst enableScroll = () => {\r\n   document.body.style.cssText = '';\r\n   window.scroll({\r\n      top: document.body.dataset.scrollY\r\n   });\r\n};\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./src/modules/postData.js\nconst postData = async cart => {\r\n   try {\r\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\r\n         method: 'POST',\r\n         body: JSON.stringify(cart),\r\n         headers: {\r\n            'Content-type': 'application/json; charset=UTF-8',\r\n         },\r\n      });\r\n      const resp = await response.json();\r\n      return resp;\r\n   } catch (err) {\r\n      console.error(err);\r\n   }\r\n};\r\n\r\n/* harmony default export */ const modules_postData = (postData);\r\n\n;// CONCATENATED MODULE: ./src/modules/clearForm.js\nconst clearForm = (inputs, sendMessage, modal) => {\r\n   inputs.forEach(item => item.value = '');\r\n   sendMessage ? sendMessage.remove() : false;\r\n   modal ? modal() : false;\r\n};\r\n/* harmony default export */ const modules_clearForm = (clearForm);\n;// CONCATENATED MODULE: ./src/modules/checkForm.js\n\r\n\r\n\r\nconst checkForm = async (e, form, inputs, modal) => {\r\n   e.preventDefault();\r\n   let orderMessage = document.querySelector('.order-message');\r\n   if (!orderMessage) {\r\n      const addMessage = `<span class=\"order-message\"><span>`;\r\n      form.insertAdjacentHTML('beforeEnd', addMessage);\r\n      orderMessage = document.querySelector('.order-message');\r\n      orderMessage.style.display = \"block\";\r\n      orderMessage.style.textAlign = \"center\";\r\n      orderMessage.style.fontSize = \"20px\";\r\n      orderMessage.style.padding = \"25px\";\r\n   }\r\n   const checkInput = () => {\r\n      return inputs.every(item => item.value !== '');\r\n   };\r\n   if (checkInput()) {\r\n      await modules_postData();\r\n      orderMessage.classList.add('active');\r\n      orderMessage.textContent = `Заявка успешно отправлена!`;\r\n      setTimeout(() => {\r\n         modules_clearForm(inputs, orderMessage, modal);\r\n      }, 2000);\r\n   } else {\r\n      orderMessage.textContent = `Заполните все поля!`;\r\n      orderMessage.classList.add('active');\r\n   }\r\n};\r\n/* harmony default export */ const modules_checkForm = (checkForm);\n;// CONCATENATED MODULE: ./src/modules/modal.js\n\r\n\r\n\r\n\r\nconst modal = () => {\r\n   const getModal = document.querySelector('.modal');\r\n   const mainButton = document.querySelector('.main__button');\r\n   const modalInputs = document.querySelectorAll('.modal__input');\r\n   const form = document.querySelector('.modal__form');\r\n\r\n   const closeModal = () => {\r\n      getModal.classList.add('hidden');\r\n      enableScroll();\r\n   };\r\n   const sendForm = async e => {\r\n      await modules_checkForm(e, form, [...modalInputs], closeModal);\r\n   };\r\n   const controlModal = e => {\r\n      const target = e.target;\r\n      if (target.closest('.modal__close') || target.closest('.overlay')) {\r\n         const orderMessage = document.querySelector('.order-message');\r\n         modules_clearForm([...modalInputs], orderMessage, closeModal);\r\n      }\r\n      if (target.closest('.modal__button')) {\r\n         sendForm(e);\r\n      }\r\n   };\r\n   const openModal = e => {\r\n      e.preventDefault();\r\n      disableScroll();\r\n      getModal.classList.remove('hidden');\r\n      getModal.addEventListener('click', controlModal);\r\n   };\r\n\r\n   mainButton.addEventListener('click', openModal);\r\n};\r\n\r\n/* harmony default export */ const modules_modal = (modal);\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/common.js\nconst checkBehavior = (behavior) => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\nfunction elementScrollXY(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\nconst failedExecute = (method, object, reason = \"cannot convert to dictionary.\") => `Failed to execute '${method}' on '${object}': ${reason}`;\nconst failedExecuteInvalidEnumValue = (method, object, value) => failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n/* eslint-disable */\nconst backupMethod = (proto, method, fallback) => {\n    var _a;\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n    if (!proto[backup] && proto[method] && !((_a = proto[method]) === null || _a === void 0 ? void 0 : _a.__isPolyfill)) {\n        proto[backup] = proto[method];\n    }\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\nconst isObject = (value) => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\nconst isScrollBehaviorSupported = () => \"scrollBehavior\" in window.document.documentElement.style;\nconst markPolyfill = (method) => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\nconst modifyPrototypes = (prop, func) => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nconst scrollingElement = (element) => element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n//# sourceMappingURL=common.js.map\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/scroll-step.js\nconst ease = (k) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n/* eslint-disable */\nfunction now() {\n    var _a;\n    let fn;\n    if ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) {\n        fn = () => window.performance.now();\n    }\n    else {\n        fn = () => window.Date.now();\n    }\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\nconst DURATION = 500;\nconst step = (context) => {\n    const currentTime = now();\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n    context.method(currentX, currentY);\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n//# sourceMappingURL=scroll-step.js.map\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/scroll.js\n\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value) => {\n    if (!isFinite(value)) {\n        return 0;\n    }\n    return Number(value);\n};\nconst isConnected = (node) => {\n    var _a;\n    return ((_a = node.isConnected) !== null && _a !== void 0 ? _a : (!node.ownerDocument ||\n        // eslint-disable-next-line no-bitwise\n        !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1)));\n};\nconst scrollWithOptions = (element, options, config) => {\n    var _a, _b;\n    if (!isConnected(element)) {\n        return;\n    }\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n    const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);\n    const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element), \"scroll\", fallback).bind(element);\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n    const context = Object.assign(Object.assign({}, config), { timeStamp: now(), startX,\n        startY,\n        targetX,\n        targetY, rafId: 0, method, callback: removeEventListener });\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    step(context);\n};\nconst isWindow = (obj) => obj.window === obj;\nconst createScroll = (scrollName) => (target, scrollOptions, config) => {\n    const [element, scrollType] = isWindow(target)\n        ? [scrollingElement(target.document.documentElement), \"Window\"]\n        : [target, \"Element\"];\n    const options = scrollOptions !== null && scrollOptions !== void 0 ? scrollOptions : {};\n    if (!isObject(options)) {\n        throw new TypeError(failedExecute(scrollName, scrollType));\n    }\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n    }\n    if (scrollName === \"scrollBy\") {\n        options.left = nonFinite(options.left) + element.scrollLeft;\n        options.top = nonFinite(options.top) + element.scrollTop;\n    }\n    scrollWithOptions(element, options, config);\n};\nconst scroll_scroll = /* #__PURE__ */ createScroll(\"scroll\");\nconst scrollTo = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollTo\")));\nconst scrollBy = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollBy\")));\nconst elementScroll = scroll_scroll;\nconst elementScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst elementScrollBy = (/* unused pure expression or super */ null && (scrollBy));\nconst windowScroll = (/* unused pure expression or super */ null && (scroll_scroll));\nconst windowScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst windowScrollBy = (/* unused pure expression or super */ null && (scrollBy));\n//# sourceMappingURL=scroll.js.map\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/scrollIntoView.js\n/* eslint-disable no-bitwise */\n\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode) => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return 0 /* HorizontalTb */;\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return 1 /* VerticalRl */;\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return 2 /* VerticalLr */;\n        case \"sideways-rl\":\n            return 3 /* SidewaysRl */;\n        case \"sideways-lr\":\n            return 4 /* SidewaysLr */;\n    }\n    return 0 /* HorizontalTb */;\n};\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= 2 /* ReverseVertical */;\n    }\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case 0 /* HorizontalTb */:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case 1 /* VerticalRl */:\n        case 3 /* SidewaysRl */:\n            //  reverse horizontal\n            layout ^= 1 /* ReverseHorizontal */;\n            break;\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case 4 /* SidewaysLr */:\n            // reverse vertical\n            layout ^= 2 /* ReverseVertical */;\n            break;\n    }\n    return [layout, hPos, vPos];\n};\nconst isXReversed = (computedStyle) => {\n    const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n    return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return 1 /* CenterAlways */;\n            case \"nearest\":\n                return 0 /* ToEdgeIfNeeded */;\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;\n            }\n        }\n    });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n    if (align !== 0 /* ToEdgeIfNeeded */) {\n        return align;\n    }\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n        return null;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n        return 2 /* LeftOrTop */;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n        return 3 /* RightOrBottom */;\n    }\n    return null;\n};\nconst canOverflow = (overflow) => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\nconst getFrameElement = (element) => {\n    var _a;\n    try {\n        return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n    }\n    catch (_b) {\n        return null;\n    }\n};\nconst isScrollable = (element, computedStyle) => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element));\n    }\n    return false;\n};\nconst parentElement = (element) => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return pNode.host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n    return pElement;\n};\nconst clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\nconst getSupportedScrollMarginProperty = (ownerDocument) => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return [\"scroll-margin\", \"scroll-snap-margin\"].filter((property) => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n    const scrollMarginValue = (edge) => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\nconst calcAlignEdge = (align, start, end) => {\n    switch (align) {\n        case 1 /* CenterAlways */:\n            return (start + end) / 2;\n        case 3 /* RightOrBottom */:\n            return end;\n        case 2 /* LeftOrTop */:\n        case 0 /* ToEdgeIfNeeded */:\n            return start;\n    }\n};\nconst getFrameViewport = (frame, frameRect) => {\n    var _a, _b, _c;\n    const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n    const [x, y, width, height] = frame === scrollingElement(frame)\n        ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight]\n        : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n    return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions = [];\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n    if (!ownerWindow) {\n        return actions;\n    }\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n    const writingMode = normalizeWritingMode(computedStyle.writingMode ||\n        computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n        computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n        const frameRect = frame.getBoundingClientRect();\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n        const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n    return actions;\n};\nconst scrollIntoView = (element, scrollIntoViewOptions, config) => {\n    const options = scrollIntoViewOptions || {};\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n    const actions = computeScrollIntoView(element, options);\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\nconst elementScrollIntoView = scrollIntoView;\n//# sourceMappingURL=scrollIntoView.js.map\n;// CONCATENATED MODULE: ./src/modules/smothScroll.js\n\r\n\r\nconst smothScroll = () => {\r\n   const getNav = document.querySelector('.menu-list');\r\n   const mainScroll = document.querySelector('.main__scroll');\r\n\r\n   const goSection = target => {\r\n      const getId = target.getAttribute('href').slice(1);\r\n      const getSection = document.getElementById(getId);\r\n      if (getSection) {\r\n         elementScrollIntoView(getSection, { behavior: \"smooth\", block: \"center\", inline: \"center\" });\r\n      }\r\n   };\r\n   const activeLink = (e) => {\r\n      e.preventDefault();\r\n      const target = e.target;\r\n      if (target.closest('.menu-list__item')) {\r\n         const getParent = target.closest('.menu-list__item');\r\n         const getLink = getParent.querySelector('.menu-list__link');\r\n         goSection(getLink);\r\n      }\r\n   };\r\n\r\n   getNav.addEventListener('click', activeLink);\r\n   mainScroll.addEventListener('click', e => {\r\n      e.preventDefault();\r\n      goSection(mainScroll);\r\n   });\r\n};\r\n/* harmony default export */ const modules_smothScroll = (smothScroll);\n;// CONCATENATED MODULE: ./src/modules/tabs.js\nconst tabs = () => {\r\n   const designList = document.querySelector('.design-list');\r\n   const getTabs = document.querySelectorAll('.design-list__item');\r\n   const tabsDescription = document.querySelectorAll('.design__descr');\r\n   const designBlock = document.querySelectorAll('.design-block > img');\r\n   const designImg = document.querySelectorAll('.design-images');\r\n\r\n   let activeTarget = '';\r\n\r\n   const activeTab = e => {\r\n      e.preventDefault();\r\n      const target = e.target;\r\n      const activeBlock = selector => {\r\n         selector.forEach(item => {\r\n            item.dataset.tabsField === activeTarget ?\r\n               item.classList.remove('hidden') :\r\n               item.classList.add('hidden');\r\n         });\r\n      };\r\n      if (target.closest('.design-list__item') && !target.closest('.design-list__item_active')) {\r\n         getTabs.forEach(item => item.classList.remove('design-list__item_active'));\r\n         target.classList.add('design-list__item_active');\r\n         activeTarget = target.dataset.tabsHandler;\r\n         document.querySelector(\"title\").textContent = `Портфолио: ${target.textContent}`;\r\n         activeBlock(tabsDescription);\r\n         activeBlock(designImg);\r\n         activeBlock(designBlock);\r\n      }\r\n   };\r\n\r\n   designList.addEventListener('click', activeTab);\r\n};\r\n\r\n/* harmony default export */ const modules_tabs = (tabs);\n;// CONCATENATED MODULE: ./src/modules/mainForm.js\n\r\n\r\nconst mainForm = () => {\r\n   const formButton = document.querySelector('.form__button');\r\n   const form = document.querySelector('.form-test-drive');\r\n   const getInputs = document.querySelectorAll('.form-test-drive > input');\r\n\r\n   const sendForm = async e => {\r\n      await console.log(modules_checkForm(e, form, [...getInputs]));\r\n   };\r\n   formButton.addEventListener('click', sendForm);\r\n};\r\n/* harmony default export */ const modules_mainForm = (mainForm);\n;// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmodules_tabs();\r\nmodules_menu();\r\nmodules_smothScroll();\r\nmodules_accordeon();\r\nmodules_countTimer('31 march 2022');\r\nmodules_modal();\r\nmodules_mainForm();\r\n\r\ndocument.getElementById('contacts').style.paddingBottom = '100px';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFlBQVk7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsR0FBRyxLQUFLO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwRkFBMEY7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxTQUFTLGFBQWE7QUFDdEIsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckIsS0FBSztBQUNMO0FBQ087QUFDUCwwQzs7QUMxWWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCLGVBQWUsdURBQXVEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMERBQWUsV0FBVyxFOztBQzdCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLG1CQUFtQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBZSxJQUFJLEU7O0FDakNvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSx1REFBZSxRQUFRLEU7O0FDWnFCO0FBQ0U7QUFDWjtBQUNFO0FBQ1k7QUFDZDtBQUNRO0FBQzFDO0FBQ0EsWUFBSTtBQUNKLFlBQUk7QUFDSixtQkFBVztBQUNYLGlCQUFTO0FBQ1Qsa0JBQVU7QUFDVixhQUFLO0FBQ0wsZ0JBQVE7QUFDUjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvYWNjb3JkZW9uLmpzPzRhMmYiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvY291bnRUaW1lci5qcz8wZGY4Iiwid2VicGFjazovL3BvcnRmb2xpby8uL3NyYy9tb2R1bGVzL21lbnUuanM/MmZhZCIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9ibG9ja1Njcm9sbGVkLmpzP2E0OTYiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvcG9zdERhdGEuanM/YWVlMCIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9jbGVhckZvcm0uanM/ZWUwMiIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9jaGVja0Zvcm0uanM/MzM1ZCIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9tb2RhbC5qcz84YmU1Iiwid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL2NvbW1vbi5qcz9lMzVjIiwid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL3Njcm9sbC1zdGVwLmpzP2MzMjEiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbC9saWIvc2Nyb2xsLmpzP2Q4MWIiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3NlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbC9saWIvc2Nyb2xsSW50b1ZpZXcuanM/NTIxNiIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9zbW90aFNjcm9sbC5qcz82ZTc5Iiwid2VicGFjazovL3BvcnRmb2xpby8uL3NyYy9tb2R1bGVzL3RhYnMuanM/YjdiMiIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9tYWluRm9ybS5qcz8yNjJmIiwid2VicGFjazovL3BvcnRmb2xpby8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFjY29yZGVvbiA9ICgpID0+IHtcclxuICAgY29uc3QgZmVhdHVyZUxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmVhdHVyZS1saXN0Jyk7XHJcbiAgIGNvbnN0IGZlYXR1cmVMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mZWF0dXJlX19saW5rJyk7XHJcbiAgIGNvbnN0IGZlYXR1cmVTdWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZlYXR1cmUtc3ViJyk7XHJcblxyXG4gICBjb25zdCBhY3RpdmVJdGVtID0gZSA9PiB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLmZlYXR1cmVfX2xpbmsnKSAmJiAhdGFyZ2V0LmNsb3Nlc3QoJy5mZWF0dXJlX19saW5rX2FjdGl2ZScpKSB7XHJcbiAgICAgICAgIGNvbnN0IGdldFBhcmVudCA9IHRhcmdldC5jbG9zZXN0KCcuZmVhdHVyZV9fbGluaycpLnBhcmVudE5vZGU7XHJcbiAgICAgICAgIGNvbnN0IGdldExpbmsgPSBnZXRQYXJlbnQucXVlcnlTZWxlY3RvcignLmZlYXR1cmVfX2xpbmsnKTtcclxuICAgICAgICAgY29uc3QgZ2V0U3ViID0gZ2V0UGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5mZWF0dXJlLXN1YicpO1xyXG4gICAgICAgICBmZWF0dXJlTGlua3MuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnZmVhdHVyZV9fbGlua19hY3RpdmUnKSk7XHJcbiAgICAgICAgIGZlYXR1cmVTdWJzLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpKTtcclxuICAgICAgICAgZ2V0TGluay5jbGFzc0xpc3QuYWRkKCdmZWF0dXJlX19saW5rX2FjdGl2ZScpO1xyXG4gICAgICAgICBnZXRTdWIuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgIH1cclxuICAgfTtcclxuXHJcbiAgIGZlYXR1cmVMaXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYWN0aXZlSXRlbSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhY2NvcmRlb247IiwiY29uc3QgY291bnRUaW1lciA9IGRlYWRsaW5lID0+IHtcclxuXHJcbiAgIGNvbnN0IGdldFRpbWVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRpbWVyX190aW1lJyk7XHJcblxyXG4gICBjb25zdCBnZXRUaW1lUmVtYWluaW5nID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRlU3RvcCA9IG5ldyBEYXRlKGRlYWRsaW5lKSxcclxuICAgICAgICAgZGF0ZU5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAgICAgICB0aW1lclJlbWFpbmluZyA9IChkYXRlU3RvcCAtIGRhdGVOb3cpIC8gMTAwMCxcclxuICAgICAgICAgc2Vjb25kcyA9IE1hdGguZmxvb3IodGltZXJSZW1haW5pbmcgJSA2MCksXHJcbiAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh0aW1lclJlbWFpbmluZyAvIDYwKSAlIDYwKSxcclxuICAgICAgICAgaG91cnMgPSBNYXRoLmZsb29yKHRpbWVyUmVtYWluaW5nIC8gNjAgLyA2MCk7XHJcbiAgICAgIHJldHVybiB7IHRpbWVyUmVtYWluaW5nLCBob3VycywgbWludXRlcywgc2Vjb25kcyB9O1xyXG4gICB9O1xyXG4gICBjb25zdCBhZGRaZXJvID0gbnVtID0+IHtcclxuICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8PSA5KSB7XHJcbiAgICAgICAgIHJldHVybiBgMCR7bnVtfWA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgIHJldHVybiBudW07XHJcbiAgICAgIH1cclxuICAgfTtcclxuICAgY29uc3QgdXBkYXRlQ2xvY2sgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRpbWVyID0gZ2V0VGltZVJlbWFpbmluZygpO1xyXG4gICAgICBpZiAodGltZXIudGltZXJSZW1haW5pbmcgPiAwKSB7XHJcbiAgICAgICAgIGdldFRpbWVyLmlubmVySFRNTCA9IGAke2FkZFplcm8odGltZXIuaG91cnMpfToke2FkZFplcm8odGltZXIubWludXRlcyl9OiR7YWRkWmVybyh0aW1lci5zZWNvbmRzKX1gO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICBnZXRUaW1lci50ZXh0Q29udGVudCA9IGAkeycwMDowMDowMCd9YDtcclxuICAgICAgICAgY2xlYXJJbnRlcnZhbChpZEludGVydmFsKTtcclxuICAgICAgfVxyXG4gICB9O1xyXG4gICBjb25zdCBpZEludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlQ2xvY2ssIDEwMDApO1xyXG4gICB1cGRhdGVDbG9jaygpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY291bnRUaW1lcjtcclxuIiwiY29uc3QgbWVudSA9ICgpID0+IHtcclxuICAgY29uc3QgaHVtYnVyZ2VyTWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5odW1idXJnZXItbWVudScpO1xyXG4gICBjb25zdCBtZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1lbnUnKTtcclxuXHJcbiAgIGNvbnN0IG9wZW5NZW51ID0gKCkgPT4ge1xyXG4gICAgICBtZW51LnN0eWxlLnRvcCA9ICcwJztcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbG9zZU1lbnUpO1xyXG4gICB9O1xyXG4gICBjb25zdCBjbG9zZU1lbnUgPSBlID0+IHtcclxuICAgICAgaWYgKCFlLnRhcmdldC5jbG9zZXN0KCcubWVudS1saXN0JykgJiYgIWUudGFyZ2V0LmNsb3Nlc3QoJy5odW1idXJnZXItbWVudScpIHx8IGUudGFyZ2V0LmNsb3Nlc3QoJy5tZW51LWxpc3RfX2l0ZW0nKSkge1xyXG4gICAgICAgICBtZW51LnN0eWxlLnRvcCA9ICctMzAwcHgnO1xyXG4gICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlTWVudSk7XHJcbiAgICAgIH1cclxuICAgfTtcclxuICAgaHVtYnVyZ2VyTWVudS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9wZW5NZW51KTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1lbnU7IiwiY29uc3QgZGlzYWJsZVNjcm9sbCA9ICgpID0+IHtcclxuICAgZG9jdW1lbnQuYm9keS5kYXRhc2V0LnNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcclxuXHJcbiAgIGNvbnN0IHNjcm9sbFdpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xyXG5cclxuICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jc3NUZXh0ID0gYFxyXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICAgIHRvcDogLSR7d2luZG93LnNjcm9sbFl9cHg7XHJcbiAgICAgIGxlZnQ6IDA7XHJcbiAgICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICBoZWlnaHQ6IDEwMHZoO1xyXG4gICAgICBwYWRkaW5nLXJpZ2h0OiAke3Njcm9sbFdpZHRofXB4O1xyXG4gICBgO1xyXG59O1xyXG5jb25zdCBlbmFibGVTY3JvbGwgPSAoKSA9PiB7XHJcbiAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3NzVGV4dCA9ICcnO1xyXG4gICB3aW5kb3cuc2Nyb2xsKHtcclxuICAgICAgdG9wOiBkb2N1bWVudC5ib2R5LmRhdGFzZXQuc2Nyb2xsWVxyXG4gICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCB7IGRpc2FibGVTY3JvbGwsIGVuYWJsZVNjcm9sbCB9O1xyXG4iLCJjb25zdCBwb3N0RGF0YSA9IGFzeW5jIGNhcnQgPT4ge1xyXG4gICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2pzb25wbGFjZWhvbGRlci50eXBpY29kZS5jb20vcG9zdHMnLCB7XHJcbiAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjYXJ0KSxcclxuICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnLFxyXG4gICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHBvc3REYXRhO1xyXG4iLCJjb25zdCBjbGVhckZvcm0gPSAoaW5wdXRzLCBzZW5kTWVzc2FnZSwgbW9kYWwpID0+IHtcclxuICAgaW5wdXRzLmZvckVhY2goaXRlbSA9PiBpdGVtLnZhbHVlID0gJycpO1xyXG4gICBzZW5kTWVzc2FnZSA/IHNlbmRNZXNzYWdlLnJlbW92ZSgpIDogZmFsc2U7XHJcbiAgIG1vZGFsID8gbW9kYWwoKSA6IGZhbHNlO1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBjbGVhckZvcm07IiwiaW1wb3J0IHBvc3REYXRhIGZyb20gXCIuL3Bvc3REYXRhLmpzXCI7XHJcbmltcG9ydCBjbGVhckZvcm0gZnJvbSBcIi4vY2xlYXJGb3JtLmpzXCI7XHJcblxyXG5jb25zdCBjaGVja0Zvcm0gPSBhc3luYyAoZSwgZm9ybSwgaW5wdXRzLCBtb2RhbCkgPT4ge1xyXG4gICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgIGxldCBvcmRlck1lc3NhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub3JkZXItbWVzc2FnZScpO1xyXG4gICBpZiAoIW9yZGVyTWVzc2FnZSkge1xyXG4gICAgICBjb25zdCBhZGRNZXNzYWdlID0gYDxzcGFuIGNsYXNzPVwib3JkZXItbWVzc2FnZVwiPjxzcGFuPmA7XHJcbiAgICAgIGZvcm0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVFbmQnLCBhZGRNZXNzYWdlKTtcclxuICAgICAgb3JkZXJNZXNzYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9yZGVyLW1lc3NhZ2UnKTtcclxuICAgICAgb3JkZXJNZXNzYWdlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgIG9yZGVyTWVzc2FnZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICBvcmRlck1lc3NhZ2Uuc3R5bGUuZm9udFNpemUgPSBcIjIwcHhcIjtcclxuICAgICAgb3JkZXJNZXNzYWdlLnN0eWxlLnBhZGRpbmcgPSBcIjI1cHhcIjtcclxuICAgfVxyXG4gICBjb25zdCBjaGVja0lucHV0ID0gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gaW5wdXRzLmV2ZXJ5KGl0ZW0gPT4gaXRlbS52YWx1ZSAhPT0gJycpO1xyXG4gICB9O1xyXG4gICBpZiAoY2hlY2tJbnB1dCgpKSB7XHJcbiAgICAgIGF3YWl0IHBvc3REYXRhKCk7XHJcbiAgICAgIG9yZGVyTWVzc2FnZS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuICAgICAgb3JkZXJNZXNzYWdlLnRleHRDb250ZW50ID0gYNCX0LDRj9Cy0LrQsCDRg9GB0L/QtdGI0L3QviDQvtGC0L/RgNCw0LLQu9C10L3QsCFgO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgY2xlYXJGb3JtKGlucHV0cywgb3JkZXJNZXNzYWdlLCBtb2RhbCk7XHJcbiAgICAgIH0sIDIwMDApO1xyXG4gICB9IGVsc2Uge1xyXG4gICAgICBvcmRlck1lc3NhZ2UudGV4dENvbnRlbnQgPSBg0JfQsNC/0L7Qu9C90LjRgtC1INCy0YHQtSDQv9C+0LvRjyFgO1xyXG4gICAgICBvcmRlck1lc3NhZ2UuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgIH1cclxufTtcclxuZXhwb3J0IGRlZmF1bHQgY2hlY2tGb3JtOyIsImltcG9ydCB7IGRpc2FibGVTY3JvbGwsIGVuYWJsZVNjcm9sbCB9IGZyb20gXCIuL2Jsb2NrU2Nyb2xsZWQuanNcIjtcclxuaW1wb3J0IGNoZWNrRm9ybSBmcm9tIFwiLi9jaGVja0Zvcm0uanNcIjtcclxuaW1wb3J0IGNsZWFyRm9ybSBmcm9tIFwiLi9jbGVhckZvcm0uanNcIjtcclxuXHJcbmNvbnN0IG1vZGFsID0gKCkgPT4ge1xyXG4gICBjb25zdCBnZXRNb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbCcpO1xyXG4gICBjb25zdCBtYWluQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW5fX2J1dHRvbicpO1xyXG4gICBjb25zdCBtb2RhbElucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RhbF9faW5wdXQnKTtcclxuICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbF9fZm9ybScpO1xyXG5cclxuICAgY29uc3QgY2xvc2VNb2RhbCA9ICgpID0+IHtcclxuICAgICAgZ2V0TW9kYWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgIGVuYWJsZVNjcm9sbCgpO1xyXG4gICB9O1xyXG4gICBjb25zdCBzZW5kRm9ybSA9IGFzeW5jIGUgPT4ge1xyXG4gICAgICBhd2FpdCBjaGVja0Zvcm0oZSwgZm9ybSwgWy4uLm1vZGFsSW5wdXRzXSwgY2xvc2VNb2RhbCk7XHJcbiAgIH07XHJcbiAgIGNvbnN0IGNvbnRyb2xNb2RhbCA9IGUgPT4ge1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcubW9kYWxfX2Nsb3NlJykgfHwgdGFyZ2V0LmNsb3Nlc3QoJy5vdmVybGF5JykpIHtcclxuICAgICAgICAgY29uc3Qgb3JkZXJNZXNzYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9yZGVyLW1lc3NhZ2UnKTtcclxuICAgICAgICAgY2xlYXJGb3JtKFsuLi5tb2RhbElucHV0c10sIG9yZGVyTWVzc2FnZSwgY2xvc2VNb2RhbCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcubW9kYWxfX2J1dHRvbicpKSB7XHJcbiAgICAgICAgIHNlbmRGb3JtKGUpO1xyXG4gICAgICB9XHJcbiAgIH07XHJcbiAgIGNvbnN0IG9wZW5Nb2RhbCA9IGUgPT4ge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGRpc2FibGVTY3JvbGwoKTtcclxuICAgICAgZ2V0TW9kYWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgIGdldE1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY29udHJvbE1vZGFsKTtcclxuICAgfTtcclxuXHJcbiAgIG1haW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvcGVuTW9kYWwpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbW9kYWw7IiwiZXhwb3J0IGNvbnN0IGNoZWNrQmVoYXZpb3IgPSAoYmVoYXZpb3IpID0+IHtcbiAgICByZXR1cm4gYmVoYXZpb3IgPT09IHVuZGVmaW5lZCB8fCBiZWhhdmlvciA9PT0gXCJhdXRvXCIgfHwgYmVoYXZpb3IgPT09IFwiaW5zdGFudFwiIHx8IGJlaGF2aW9yID09PSBcInNtb290aFwiO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50U2Nyb2xsWFkoeCwgeSkge1xuICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xufVxuZXhwb3J0IGNvbnN0IGZhaWxlZEV4ZWN1dGUgPSAobWV0aG9kLCBvYmplY3QsIHJlYXNvbiA9IFwiY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5cIikgPT4gYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZH0nIG9uICcke29iamVjdH0nOiAke3JlYXNvbn1gO1xuZXhwb3J0IGNvbnN0IGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlID0gKG1ldGhvZCwgb2JqZWN0LCB2YWx1ZSkgPT4gZmFpbGVkRXhlY3V0ZShtZXRob2QsIG9iamVjdCwgYFRoZSBwcm92aWRlZCB2YWx1ZSAnJHt2YWx1ZX0nIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgb2YgdHlwZSBTY3JvbGxCZWhhdmlvci5gKTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5leHBvcnQgY29uc3QgYmFja3VwTWV0aG9kID0gKHByb3RvLCBtZXRob2QsIGZhbGxiYWNrKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGJhY2t1cCA9IGBfX1NFQU1MRVNTLkJBQ0tVUCQke21ldGhvZH1gO1xuICAgIGlmICghcHJvdG9bYmFja3VwXSAmJiBwcm90b1ttZXRob2RdICYmICEoKF9hID0gcHJvdG9bbWV0aG9kXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9faXNQb2x5ZmlsbCkpIHtcbiAgICAgICAgcHJvdG9bYmFja3VwXSA9IHByb3RvW21ldGhvZF07XG4gICAgfVxuICAgIHJldHVybiBwcm90b1tiYWNrdXBdIHx8IGZhbGxiYWNrO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG59O1xuZXhwb3J0IGNvbnN0IGlzU2Nyb2xsQmVoYXZpb3JTdXBwb3J0ZWQgPSAoKSA9PiBcInNjcm9sbEJlaGF2aW9yXCIgaW4gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmV4cG9ydCBjb25zdCBtYXJrUG9seWZpbGwgPSAobWV0aG9kKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJfX2lzUG9seWZpbGxcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07XG5leHBvcnQgY29uc3QgbW9kaWZ5UHJvdG90eXBlcyA9IChwcm9wLCBmdW5jKSA9PiB7XG4gICAgbWFya1BvbHlmaWxsKGZ1bmMpO1xuICAgIFtIVE1MRWxlbWVudC5wcm90b3R5cGUsIFNWR0VsZW1lbnQucHJvdG90eXBlLCBFbGVtZW50LnByb3RvdHlwZV0uZm9yRWFjaCgocHJvdG90eXBlKSA9PiB7XG4gICAgICAgIGJhY2t1cE1ldGhvZChwcm90b3R5cGUsIHByb3ApO1xuICAgICAgICBwcm90b3R5cGVbcHJvcF0gPSBmdW5jO1xuICAgIH0pO1xufTtcbi8qKlxuICogLSBPbiBDaHJvbWUgYW5kIEZpcmVmb3gsIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgd2lsbCByZXR1cm4gdGhlIDxodG1sPiBlbGVtZW50LlxuICogLSBTYWZhcmksIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgd2lsbCByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LlxuICogLSBPbiBFZGdlLCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHdpbGwgcmV0dXJuIHRoZSA8Ym9keT4gZWxlbWVudC5cbiAqIC0gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQsIGJ1dCB5b3UgY2FuIGFzc3VtZSBpdHMgPGh0bWw+LlxuICovXG5leHBvcnQgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCIsImNvbnN0IGVhc2UgPSAoaykgPT4ge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmbjtcbiAgICBpZiAoKF9hID0gd2luZG93LnBlcmZvcm1hbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm93KSB7XG4gICAgICAgIGZuID0gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm4gPSAoKSA9PiB3aW5kb3cuRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5vdyA9IGZuO1xuICAgIHJldHVybiBmbigpO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuY29uc3QgRFVSQVRJT04gPSA1MDA7XG5leHBvcnQgY29uc3Qgc3RlcCA9IChjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gKGN1cnJlbnRUaW1lIC0gY29udGV4dC50aW1lU3RhbXApIC8gKGNvbnRleHQuZHVyYXRpb24gfHwgRFVSQVRJT04pO1xuICAgIGlmIChlbGFwc2VkID4gMSkge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZChjb250ZXh0LnRhcmdldFgsIGNvbnRleHQudGFyZ2V0WSk7XG4gICAgICAgIGNvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IChjb250ZXh0LnRpbWluZ0Z1bmMgfHwgZWFzZSkoZWxhcHNlZCk7XG4gICAgY29uc3QgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnRhcmdldFggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICBjb25zdCBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQudGFyZ2V0WSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuICAgIGNvbnRleHQubWV0aG9kKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgY29udGV4dC5yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzdGVwKGNvbnRleHQpO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC1zdGVwLmpzLm1hcCIsImltcG9ydCB7IGJhY2t1cE1ldGhvZCwgY2hlY2tCZWhhdmlvciwgZWxlbWVudFNjcm9sbFhZLCBmYWlsZWRFeGVjdXRlLCBmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZSwgaXNPYmplY3QsIHNjcm9sbGluZ0VsZW1lbnQsIH0gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBub3csIHN0ZXAgfSBmcm9tIFwiLi9zY3JvbGwtc3RlcC5qc1wiO1xuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLXZpZXcvI25vcm1hbGl6ZS1ub24tZmluaXRlLXZhbHVlc1xuY29uc3Qgbm9uRmluaXRlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xufTtcbmNvbnN0IGlzQ29ubmVjdGVkID0gKG5vZGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBub2RlLmlzQ29ubmVjdGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoIW5vZGUub3duZXJEb2N1bWVudCB8fFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAhKG5vZGUub3duZXJEb2N1bWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIC8qKiBET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQgKi8gMSkpKTtcbn07XG5jb25zdCBzY3JvbGxXaXRoT3B0aW9ucyA9IChlbGVtZW50LCBvcHRpb25zLCBjb25maWcpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghaXNDb25uZWN0ZWQoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgY29uc3Qgc3RhcnRZID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgY29uc3QgdGFyZ2V0WCA9IG5vbkZpbml0ZSgoX2EgPSBvcHRpb25zLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0YXJ0WCk7XG4gICAgY29uc3QgdGFyZ2V0WSA9IG5vbkZpbml0ZSgoX2IgPSBvcHRpb25zLnRvcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc3RhcnRZKTtcbiAgICBpZiAodGFyZ2V0WCA9PT0gc3RhcnRYICYmIHRhcmdldFkgPT09IHN0YXJ0WSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZhbGxiYWNrID0gYmFja3VwTWV0aG9kKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgXCJzY3JvbGxcIiwgZWxlbWVudFNjcm9sbFhZKTtcbiAgICBjb25zdCBtZXRob2QgPSBiYWNrdXBNZXRob2QoT2JqZWN0LmdldFByb3RvdHlwZU9mKGVsZW1lbnQpLCBcInNjcm9sbFwiLCBmYWxsYmFjaykuYmluZChlbGVtZW50KTtcbiAgICBpZiAob3B0aW9ucy5iZWhhdmlvciAhPT0gXCJzbW9vdGhcIikge1xuICAgICAgICBtZXRob2QodGFyZ2V0WCwgdGFyZ2V0WSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBjYW5jZWxTY3JvbGwpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBjYW5jZWxTY3JvbGwpO1xuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyB0aW1lU3RhbXA6IG5vdygpLCBzdGFydFgsXG4gICAgICAgIHN0YXJ0WSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSwgcmFmSWQ6IDAsIG1ldGhvZCwgY2FsbGJhY2s6IHJlbW92ZUV2ZW50TGlzdGVuZXIgfSk7XG4gICAgY29uc3QgY2FuY2VsU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoY29udGV4dC5yYWZJZCk7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgY2FuY2VsU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgY2FuY2VsU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgfSk7XG4gICAgc3RlcChjb250ZXh0KTtcbn07XG5jb25zdCBpc1dpbmRvdyA9IChvYmopID0+IG9iai53aW5kb3cgPT09IG9iajtcbmNvbnN0IGNyZWF0ZVNjcm9sbCA9IChzY3JvbGxOYW1lKSA9PiAodGFyZ2V0LCBzY3JvbGxPcHRpb25zLCBjb25maWcpID0+IHtcbiAgICBjb25zdCBbZWxlbWVudCwgc2Nyb2xsVHlwZV0gPSBpc1dpbmRvdyh0YXJnZXQpXG4gICAgICAgID8gW3Njcm9sbGluZ0VsZW1lbnQodGFyZ2V0LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCksIFwiV2luZG93XCJdXG4gICAgICAgIDogW3RhcmdldCwgXCJFbGVtZW50XCJdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzY3JvbGxPcHRpb25zICE9PSBudWxsICYmIHNjcm9sbE9wdGlvbnMgIT09IHZvaWQgMCA/IHNjcm9sbE9wdGlvbnMgOiB7fTtcbiAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZmFpbGVkRXhlY3V0ZShzY3JvbGxOYW1lLCBzY3JvbGxUeXBlKSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tCZWhhdmlvcihvcHRpb25zLmJlaGF2aW9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlKHNjcm9sbE5hbWUsIHNjcm9sbFR5cGUsIG9wdGlvbnMuYmVoYXZpb3IpKTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbE5hbWUgPT09IFwic2Nyb2xsQnlcIikge1xuICAgICAgICBvcHRpb25zLmxlZnQgPSBub25GaW5pdGUob3B0aW9ucy5sZWZ0KSArIGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgb3B0aW9ucy50b3AgPSBub25GaW5pdGUob3B0aW9ucy50b3ApICsgZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfVxuICAgIHNjcm9sbFdpdGhPcHRpb25zKGVsZW1lbnQsIG9wdGlvbnMsIGNvbmZpZyk7XG59O1xuZXhwb3J0IGNvbnN0IHNjcm9sbCA9IC8qICNfX1BVUkVfXyAqLyBjcmVhdGVTY3JvbGwoXCJzY3JvbGxcIik7XG5leHBvcnQgY29uc3Qgc2Nyb2xsVG8gPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2Nyb2xsKFwic2Nyb2xsVG9cIik7XG5leHBvcnQgY29uc3Qgc2Nyb2xsQnkgPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2Nyb2xsKFwic2Nyb2xsQnlcIik7XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbCA9IHNjcm9sbDtcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsVG8gPSBzY3JvbGxUbztcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsQnkgPSBzY3JvbGxCeTtcbmV4cG9ydCBjb25zdCB3aW5kb3dTY3JvbGwgPSBzY3JvbGw7XG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsVG8gPSBzY3JvbGxUbztcbmV4cG9ydCBjb25zdCB3aW5kb3dTY3JvbGxCeSA9IHNjcm9sbEJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IGNoZWNrQmVoYXZpb3IsIGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlLCBzY3JvbGxpbmdFbGVtZW50IH0gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgeyBlbGVtZW50U2Nyb2xsIH0gZnJvbSBcIi4vc2Nyb2xsLmpzXCI7XG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMtNC8jYmxvY2stZmxvd1xuY29uc3Qgbm9ybWFsaXplV3JpdGluZ01vZGUgPSAod3JpdGluZ01vZGUpID0+IHtcbiAgICBzd2l0Y2ggKHdyaXRpbmdNb2RlKSB7XG4gICAgICAgIGNhc2UgXCJob3Jpem9udGFsLXRiXCI6XG4gICAgICAgIGNhc2UgXCJsclwiOlxuICAgICAgICBjYXNlIFwibHItdGJcIjpcbiAgICAgICAgY2FzZSBcInJsXCI6XG4gICAgICAgIGNhc2UgXCJybC10YlwiOlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogSG9yaXpvbnRhbFRiICovO1xuICAgICAgICBjYXNlIFwidmVydGljYWwtcmxcIjpcbiAgICAgICAgY2FzZSBcInRiXCI6XG4gICAgICAgIGNhc2UgXCJ0Yi1ybFwiOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVmVydGljYWxSbCAqLztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsLWxyXCI6XG4gICAgICAgIGNhc2UgXCJ0Yi1sclwiOlxuICAgICAgICAgICAgcmV0dXJuIDIgLyogVmVydGljYWxMciAqLztcbiAgICAgICAgY2FzZSBcInNpZGV3YXlzLXJsXCI6XG4gICAgICAgICAgICByZXR1cm4gMyAvKiBTaWRld2F5c1JsICovO1xuICAgICAgICBjYXNlIFwic2lkZXdheXMtbHJcIjpcbiAgICAgICAgICAgIHJldHVybiA0IC8qIFNpZGV3YXlzTHIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEhvcml6b250YWxUYiAqLztcbn07XG5jb25zdCBjYWxjUGh5c2ljYWxBeGlzID0gKHdyaXRpbmdNb2RlLCBpc0xUUiwgaFBvcywgdlBvcykgPT4ge1xuICAgIC8qKiAgMGJ7dmVydGljYWx9e2hvcml6b250YWx9ICAwOiBub3JtYWwsIDE6IHJldmVyc2UgKi9cbiAgICBsZXQgbGF5b3V0ID0gMGIwMDtcbiAgICAvKipcbiAgICAgKiBXcml0aW5nTW9kZS5WZXJ0aWNhbExyOiDihpPihpJcbiAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgKlxuICAgICAqIFJUTDog4oaR4oaSXG4gICAgICogfCAzIHwgICB8ICAgfFxuICAgICAqIHwgMiB8IDUgfCAgIHxcbiAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICovXG4gICAgaWYgKCFpc0xUUikge1xuICAgICAgICBsYXlvdXQgXj0gMiAvKiBSZXZlcnNlVmVydGljYWwgKi87XG4gICAgfVxuICAgIHN3aXRjaCAod3JpdGluZ01vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOKGk+KGklxuICAgICAgICAgKiB8IDEgfCAyIHwgMyB8XG4gICAgICAgICAqIHwgNCB8IDUgfCAgIHxcbiAgICAgICAgICogfCAgIHwgICB8ICAgfFxuICAgICAgICAgKlxuICAgICAgICAgKiBSVEw6IOKGk+KGkFxuICAgICAgICAgKiB8IDMgfCAyIHwgMSB8XG4gICAgICAgICAqIHwgICB8IDUgfCA0IHxcbiAgICAgICAgICogfCAgIHwgICB8ICAgfFxuICAgICAgICAgKi9cbiAgICAgICAgY2FzZSAwIC8qIEhvcml6b250YWxUYiAqLzpcbiAgICAgICAgICAgIC8vIHN3YXAgaG9yaXpvbnRhbCBhbmQgdmVydGljYWxcbiAgICAgICAgICAgIGxheW91dCA9IChsYXlvdXQgPj4gMSkgfCAoKGxheW91dCAmIDEpIDw8IDEpO1xuICAgICAgICAgICAgW2hQb3MsIHZQb3NdID0gW3ZQb3MsIGhQb3NdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDihpPihpBcbiAgICAgICAgICogfCAgIHwgNCB8IDEgfFxuICAgICAgICAgKiB8ICAgfCA1IHwgMiB8XG4gICAgICAgICAqIHwgICB8ICAgfCAzIHxcbiAgICAgICAgICpcbiAgICAgICAgICogUlRMOiDihpHihpBcbiAgICAgICAgICogfCAgIHwgICB8IDMgfFxuICAgICAgICAgKiB8ICAgfCA1IHwgMiB8XG4gICAgICAgICAqIHwgICB8IDQgfCAxIHxcbiAgICAgICAgICovXG4gICAgICAgIGNhc2UgMSAvKiBWZXJ0aWNhbFJsICovOlxuICAgICAgICBjYXNlIDMgLyogU2lkZXdheXNSbCAqLzpcbiAgICAgICAgICAgIC8vICByZXZlcnNlIGhvcml6b250YWxcbiAgICAgICAgICAgIGxheW91dCBePSAxIC8qIFJldmVyc2VIb3Jpem9udGFsICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDihpHihpJcbiAgICAgICAgICogfCAzIHwgICB8ICAgfFxuICAgICAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICAgICAqIHwgMSB8IDQgfCAgIHxcbiAgICAgICAgICpcbiAgICAgICAgICogUlRMOiDihpPihpJcbiAgICAgICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgICAgICovXG4gICAgICAgIGNhc2UgNCAvKiBTaWRld2F5c0xyICovOlxuICAgICAgICAgICAgLy8gcmV2ZXJzZSB2ZXJ0aWNhbFxuICAgICAgICAgICAgbGF5b3V0IF49IDIgLyogUmV2ZXJzZVZlcnRpY2FsICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBbbGF5b3V0LCBoUG9zLCB2UG9zXTtcbn07XG5jb25zdCBpc1hSZXZlcnNlZCA9IChjb21wdXRlZFN0eWxlKSA9PiB7XG4gICAgY29uc3QgbGF5b3V0ID0gY2FsY1BoeXNpY2FsQXhpcyhub3JtYWxpemVXcml0aW5nTW9kZShjb21wdXRlZFN0eWxlLndyaXRpbmdNb2RlKSwgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gIT09IFwicnRsXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVswXTtcbiAgICByZXR1cm4gKGxheW91dCAmIDEpID09PSAxO1xufTtcbi8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnRoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvZG9tL2VsZW1lbnQuY2M7bD0xMDk3LTExODk7ZHJjPTZhNzUzM2Q0YTFlOWYyMzcyMjIzYTlkOTEyYTllNTNhNmZhMzVhZTBcbmNvbnN0IHRvUGh5c2ljYWxBbGlnbm1lbnQgPSAob3B0aW9ucywgd3JpdGluZ01vZGUsIGlzTFRSKSA9PiB7XG4gICAgY29uc3QgW2xheW91dCwgaFBvcywgdlBvc10gPSBjYWxjUGh5c2ljYWxBeGlzKHdyaXRpbmdNb2RlLCBpc0xUUiwgb3B0aW9ucy5ibG9jayB8fCBcInN0YXJ0XCIsIG9wdGlvbnMuaW5saW5lIHx8IFwibmVhcmVzdFwiKTtcbiAgICByZXR1cm4gW2hQb3MsIHZQb3NdLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBDZW50ZXJBbHdheXMgKi87XG4gICAgICAgICAgICBjYXNlIFwibmVhcmVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIFRvRWRnZUlmTmVlZGVkICovO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2UgPSAobGF5b3V0ID4+IGluZGV4KSAmIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gXCJzdGFydFwiKSA9PT0gIXJldmVyc2UgPyAyIC8qIExlZnRPclRvcCAqLyA6IDMgLyogUmlnaHRPckJvdHRvbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8vIGNvZGUgZnJvbSBzdGlwc2FuL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlld1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N0aXBzYW4vY29tcHV0ZS1zY3JvbGwtaW50by12aWV3L2Jsb2IvNTM5NmM2Yjc4YWY1ZDBiYmNlMTFhN2M0ZTkzY2MzMTQ2NTQ2ZmNkMy9zcmMvaW5kZXgudHNcbi8qKlxuICogRmluZCBvdXQgd2hpY2ggZWRnZSB0byBhbGlnbiBhZ2FpbnN0IHdoZW4gbG9naWNhbCBzY3JvbGwgcG9zaXRpb24gaXMgXCJuZWFyZXN0XCJcbiAqIEludGVyZXN0aW5nIGZhY3Q6IFwibmVhcmVzdFwiIHdvcmtzIHNpbWlsYXJpbHkgdG8gXCJpZi1uZWVkZWRcIiwgaWYgdGhlIGVsZW1lbnQgaXMgZnVsbHkgdmlzaWJsZSBpdCB3aWxsIG5vdCBzY3JvbGwgaXRcbiAqXG4gKiBMZWdlbmRzOlxuICog4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUjyDilIEg4pSBIOKUgSDilJNcbiAqIOKUgiB0YXJnZXQg4pSCICAgZnJhbWVcbiAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilJcg4pSBIOKUgSDilIEg4pSbXG4gKi9cbmNvbnN0IG1hcE5lYXJlc3QgPSAoYWxpZ24sIHNjcm9sbGluZ0VkZ2VTdGFydCwgc2Nyb2xsaW5nRWRnZUVuZCwgc2Nyb2xsaW5nU2l6ZSwgZWxlbWVudEVkZ2VTdGFydCwgZWxlbWVudEVkZ2VFbmQsIGVsZW1lbnRTaXplKSA9PiB7XG4gICAgaWYgKGFsaWduICE9PSAwIC8qIFRvRWRnZUlmTmVlZGVkICovKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEEgYW5kIGVsZW1lbnQgZWRnZSBCIGFyZSBib3RoIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIHNjcm9sbGluZyBib3ggZWRnZSBCXG4gICAgICpcbiAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSDIOKUgiAg4pSCIOKUgyAgICAgICAgZG8gbm90aGluZ1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgeKUguKUgeKUgeKUguKUgeKUm1xuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqXG4gICAgICogIElmIGVsZW1lbnQgZWRnZSBDIGFuZCBlbGVtZW50IGVkZ2UgRCBhcmUgYm90aCBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBDIGFuZCBzY3JvbGxpbmcgYm94IGVkZ2UgRFxuICAgICAqXG4gICAgICogICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAqICAg4pSC4pSDICAgICAgICAg4pSD4pSCICAgICAgICBkbyBub3RoaW5nXG4gICAgICogICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAgKiAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqL1xuICAgIGlmICgoZWxlbWVudEVkZ2VTdGFydCA8IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50RWRnZUVuZCA+IHNjcm9sbGluZ0VkZ2VFbmQpIHx8XG4gICAgICAgIChlbGVtZW50RWRnZVN0YXJ0ID4gc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRFZGdlRW5kIDwgc2Nyb2xsaW5nRWRnZUVuZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUkyAgICAgICAgIOKUj+KUgeKUjOKUgeKUgeKUkOKUgeKUk1xuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmCAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICBmcm9tICDilIMgICAgICDilIMgICAgIHRvICDilIMg4pSU4pSA4pSA4pSYIOKUg1xuICAgICAqXG4gICAgICogICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbICAgICAgICAg4pSX4pSBIOKUgeKUgSDilIHilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBCIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEIgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgIOKUj+KUgSDilIHilIEg4pSB4pSTICAgICAgICAg4pSP4pSB4pSM4pSB4pSB4pSQ4pSB4pSTXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICBmcm9tICDilIMg4pSM4pSA4pSA4pSQIOKUgyAgICAgdG8gIOKUgyDilIIgIOKUgiDilINcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJsgICAgICAgICDilJfilIHilILilIHilIHilILilIHilJtcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEMgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgZWxlbWVudCB3aWR0aCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogIOKUjOKUgOKUgOKUgOKUkCAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXG4gICAgICogIOKUgiDilIMg4pSCICAgICAgIOKUgyAgICAgICAgIOKUgyAgIOKUgiAgICAg4pSDXG4gICAgICogIOKUlOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICogICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEQgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgRCBhbmQgZWxlbWVudCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAqICAgIOKUgyAgIOKUgiAgICAg4pSDICAgICDilIIgICDilIMgICAgICAgICDilIMg4pSCXG4gICAgICogICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKi9cbiAgICBpZiAoKGVsZW1lbnRFZGdlU3RhcnQgPD0gc2Nyb2xsaW5nRWRnZVN0YXJ0ICYmIGVsZW1lbnRTaXplIDw9IHNjcm9sbGluZ1NpemUpIHx8XG4gICAgICAgIChlbGVtZW50RWRnZUVuZCA+PSBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplID49IHNjcm9sbGluZ1NpemUpKSB7XG4gICAgICAgIHJldHVybiAyIC8qIExlZnRPclRvcCAqLztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEIgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQiBhbmQgZWxlbWVudCBoZWlnaHQgaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggaGVpZ2h0XG4gICAgICpcbiAgICAgKiAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJMgICAgICAgICDilI/ilIEg4pSB4pSBIOKUgeKUk1xuICAgICAqXG4gICAgICogIGZyb20gIOKUgyAgICAgIOKUgyAgICAgdG8gIOKUgyDilIzilIDilIDilJAg4pSDXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgeKUguKUgeKUgeKUguKUgeKUmyAgICAgICAgIOKUl+KUgeKUlOKUgeKUgeKUmOKUgeKUm1xuICAgICAqICAgICAgICAgIOKUlOKUgOKUgOKUmFxuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEEgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQSBhbmQgZWxlbWVudCBoZWlnaHQgaXMgZ3JlYXRlciB0aGFuIHNjcm9sbGluZyBib3ggaGVpZ2h0XG4gICAgICpcbiAgICAgKiAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJMgICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJNcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICBmcm9tICDilIMg4pSU4pSA4pSA4pSYIOKUgyAgICAgdG8gIOKUgyDilIIgIOKUgiDilINcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbICAgICAgICAg4pSX4pSB4pSU4pSB4pSB4pSY4pSB4pSbXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQyBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBDIGFuZCBlbGVtZW50IHdpZHRoIGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IHdpZHRoXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgZnJvbSAgICAgICAgICAgICAgICAgdG9cbiAgICAgKiAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAgICAqICDilIIgICAgIOKUgyAgICAg4pSCICAg4pSDICAgICAgIOKUgiDilIMgICAgICAgICDilINcbiAgICAgKiAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAgKiAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEQgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgRCBhbmQgZWxlbWVudCB3aWR0aCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAgICAgICAgICAgICAgICDilIzilIDilIDilIDilJAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUgyAgICAgICDilIIg4pSDIOKUgiAgICAgICDilIMgICAgIOKUgiAgIOKUg1xuICAgICAqICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmCAgICAgICAgICAgICDilJTilIDilIDilIDilJhcbiAgICAgKiAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJsgICAgICAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUm1xuICAgICAqXG4gICAgICovXG4gICAgaWYgKChlbGVtZW50RWRnZUVuZCA+IHNjcm9sbGluZ0VkZ2VFbmQgJiYgZWxlbWVudFNpemUgPCBzY3JvbGxpbmdTaXplKSB8fFxuICAgICAgICAoZWxlbWVudEVkZ2VTdGFydCA8IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50U2l6ZSA+IHNjcm9sbGluZ1NpemUpKSB7XG4gICAgICAgIHJldHVybiAzIC8qIFJpZ2h0T3JCb3R0b20gKi87XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGNhbk92ZXJmbG93ID0gKG92ZXJmbG93KSA9PiB7XG4gICAgcmV0dXJuIG92ZXJmbG93ICE9PSBcInZpc2libGVcIiAmJiBvdmVyZmxvdyAhPT0gXCJjbGlwXCI7XG59O1xuY29uc3QgZ2V0RnJhbWVFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcmFtZUVsZW1lbnQpIHx8IG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuY29uc3QgaXNTY3JvbGxhYmxlID0gKGVsZW1lbnQsIGNvbXB1dGVkU3R5bGUpID0+IHtcbiAgICBpZiAoZWxlbWVudC5jbGllbnRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aCkge1xuICAgICAgICByZXR1cm4gKGNhbk92ZXJmbG93KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dZKSB8fFxuICAgICAgICAgICAgY2FuT3ZlcmZsb3coY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gpIHx8XG4gICAgICAgICAgICBlbGVtZW50ID09PSBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IHBhcmVudEVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHBOb2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGNvbnN0IHBFbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChwRWxlbWVudCA9PT0gbnVsbCAmJiBwTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocE5vZGUubm9kZVR5cGUgPT09IC8qKiBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgKi8gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBwTm9kZS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwTm9kZS5ub2RlVHlwZSA9PT0gLyoqIE5vZGUuRE9DVU1FTlRfTk9ERSAqLyA5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwRWxlbWVudDtcbn07XG5jb25zdCBjbGFtcCA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBnZXRTdXBwb3J0ZWRTY3JvbGxNYXJnaW5Qcm9wZXJ0eSA9IChvd25lckRvY3VtZW50KSA9PiB7XG4gICAgLy8gV2Via2l0IHVzZXMgXCJzY3JvbGwtc25hcC1tYXJnaW5cIiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg5MjY1LlxuICAgIHJldHVybiBbXCJzY3JvbGwtbWFyZ2luXCIsIFwic2Nyb2xsLXNuYXAtbWFyZ2luXCJdLmZpbHRlcigocHJvcGVydHkpID0+IHByb3BlcnR5IGluIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKVswXTtcbn07XG5jb25zdCBnZXRFbGVtZW50U2Nyb2xsU25hcEFyZWEgPSAoZWxlbWVudCwgZWxlbWVudFJlY3QsIGNvbXB1dGVkU3R5bGUpID0+IHtcbiAgICBjb25zdCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9ID0gZWxlbWVudFJlY3Q7XG4gICAgY29uc3Qgc2Nyb2xsUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRTY3JvbGxNYXJnaW5Qcm9wZXJ0eShlbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xuICAgIGlmICghc2Nyb2xsUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxNYXJnaW5WYWx1ZSA9IChlZGdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGAke3Njcm9sbFByb3BlcnR5fS0ke2VkZ2V9YCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG4gICAgfTtcbiAgICByZXR1cm4gW1xuICAgICAgICB0b3AgLSBzY3JvbGxNYXJnaW5WYWx1ZShcInRvcFwiKSxcbiAgICAgICAgcmlnaHQgKyBzY3JvbGxNYXJnaW5WYWx1ZShcInJpZ2h0XCIpLFxuICAgICAgICBib3R0b20gKyBzY3JvbGxNYXJnaW5WYWx1ZShcImJvdHRvbVwiKSxcbiAgICAgICAgbGVmdCAtIHNjcm9sbE1hcmdpblZhbHVlKFwibGVmdFwiKSxcbiAgICBdO1xufTtcbmNvbnN0IGNhbGNBbGlnbkVkZ2UgPSAoYWxpZ24sIHN0YXJ0LCBlbmQpID0+IHtcbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgMSAvKiBDZW50ZXJBbHdheXMgKi86XG4gICAgICAgICAgICByZXR1cm4gKHN0YXJ0ICsgZW5kKSAvIDI7XG4gICAgICAgIGNhc2UgMyAvKiBSaWdodE9yQm90dG9tICovOlxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgY2FzZSAyIC8qIExlZnRPclRvcCAqLzpcbiAgICAgICAgY2FzZSAwIC8qIFRvRWRnZUlmTmVlZGVkICovOlxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbn07XG5jb25zdCBnZXRGcmFtZVZpZXdwb3J0ID0gKGZyYW1lLCBmcmFtZVJlY3QpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IChfYSA9IGZyYW1lLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aXN1YWxWaWV3cG9ydDtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBmcmFtZSA9PT0gc2Nyb2xsaW5nRWxlbWVudChmcmFtZSlcbiAgICAgICAgPyBbMCwgMCwgKF9iID0gdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgdmlzdWFsVmlld3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbFZpZXdwb3J0LndpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5jbGllbnRXaWR0aCwgKF9jID0gdmlzdWFsVmlld3BvcnQgPT09IG51bGwgfHwgdmlzdWFsVmlld3BvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbFZpZXdwb3J0LmhlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZnJhbWUuY2xpZW50SGVpZ2h0XVxuICAgICAgICA6IFtmcmFtZVJlY3QubGVmdCwgZnJhbWVSZWN0LnRvcCwgZnJhbWUuY2xpZW50V2lkdGgsIGZyYW1lLmNsaWVudEhlaWdodF07XG4gICAgY29uc3QgbGVmdCA9IHggKyBmcmFtZS5jbGllbnRMZWZ0O1xuICAgIGNvbnN0IHRvcCA9IHkgKyBmcmFtZS5jbGllbnRUb3A7XG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XTtcbn07XG5jb25zdCBjb21wdXRlU2Nyb2xsSW50b1ZpZXcgPSAoZWxlbWVudCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIENvbGxlY3QgYWxsIHRoZSBzY3JvbGxpbmcgYm94ZXMsIGFzIGRlZmluZWQgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNzY3JvbGxpbmctYm94XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIGxldCBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIGxldCBvd25lcldpbmRvdyA9IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFvd25lcldpbmRvdykge1xuICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzTFRSID0gY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gIT09IFwicnRsXCI7XG4gICAgY29uc3Qgd3JpdGluZ01vZGUgPSBub3JtYWxpemVXcml0aW5nTW9kZShjb21wdXRlZFN0eWxlLndyaXRpbmdNb2RlIHx8XG4gICAgICAgIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi13ZWJraXQtd3JpdGluZy1tb2RlXCIpIHx8XG4gICAgICAgIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi1tcy13cml0aW5nLW1vZGVcIikpO1xuICAgIGNvbnN0IFthbGlnbkgsIGFsaWduVl0gPSB0b1BoeXNpY2FsQWxpZ25tZW50KG9wdGlvbnMsIHdyaXRpbmdNb2RlLCBpc0xUUik7XG4gICAgbGV0IFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdID0gZ2V0RWxlbWVudFNjcm9sbFNuYXBBcmVhKGVsZW1lbnQsIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGNvbXB1dGVkU3R5bGUpO1xuICAgIGZvciAobGV0IGZyYW1lID0gcGFyZW50RWxlbWVudChlbGVtZW50KTsgZnJhbWUgIT09IG51bGw7IGZyYW1lID0gcGFyZW50RWxlbWVudChmcmFtZSkpIHtcbiAgICAgICAgaWYgKG93bmVyRG9jdW1lbnQgIT09IGZyYW1lLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBmcmFtZS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgaWYgKCFvd25lcldpbmRvdykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBsZWZ0OiBkWCwgdG9wOiBkWSB9ID0gZnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3AgKz0gZFk7XG4gICAgICAgICAgICByaWdodCArPSBkWDtcbiAgICAgICAgICAgIGJvdHRvbSArPSBkWTtcbiAgICAgICAgICAgIGxlZnQgKz0gZFg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoZnJhbWUpO1xuICAgICAgICBpZiAoZnJhbWVTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU2Nyb2xsYWJsZShmcmFtZSwgZnJhbWVTdHlsZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lUmVjdCA9IGZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBbZnJhbWVUb3AsIGZyYW1lUmlnaHQsIGZyYW1lQm90dG9tLCBmcmFtZUxlZnRdID0gZ2V0RnJhbWVWaWV3cG9ydChmcmFtZSwgZnJhbWVSZWN0KTtcbiAgICAgICAgY29uc3QgZUFsaWduSCA9IG1hcE5lYXJlc3QoYWxpZ25ILCBmcmFtZUxlZnQsIGZyYW1lUmlnaHQsIGZyYW1lLmNsaWVudFdpZHRoLCBsZWZ0LCByaWdodCwgcmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgZUFsaWduViA9IG1hcE5lYXJlc3QoYWxpZ25WLCBmcmFtZVRvcCwgZnJhbWVCb3R0b20sIGZyYW1lLmNsaWVudEhlaWdodCwgdG9wLCBib3R0b20sIGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIGNvbnN0IGRpZmZYID0gZUFsaWduSCA9PT0gbnVsbCA/IDAgOiBjYWxjQWxpZ25FZGdlKGVBbGlnbkgsIGxlZnQsIHJpZ2h0KSAtIGNhbGNBbGlnbkVkZ2UoZUFsaWduSCwgZnJhbWVMZWZ0LCBmcmFtZVJpZ2h0KTtcbiAgICAgICAgY29uc3QgZGlmZlkgPSBlQWxpZ25WID09PSBudWxsID8gMCA6IGNhbGNBbGlnbkVkZ2UoZUFsaWduViwgdG9wLCBib3R0b20pIC0gY2FsY0FsaWduRWRnZShlQWxpZ25WLCBmcmFtZVRvcCwgZnJhbWVCb3R0b20pO1xuICAgICAgICBjb25zdCBtb3ZlWCA9IGlzWFJldmVyc2VkKGZyYW1lU3R5bGUpXG4gICAgICAgICAgICA/IGNsYW1wKGRpZmZYLCAtZnJhbWUuc2Nyb2xsV2lkdGggKyBmcmFtZS5jbGllbnRXaWR0aCAtIGZyYW1lLnNjcm9sbExlZnQsIC1mcmFtZS5zY3JvbGxMZWZ0KVxuICAgICAgICAgICAgOiBjbGFtcChkaWZmWCwgLWZyYW1lLnNjcm9sbExlZnQsIGZyYW1lLnNjcm9sbFdpZHRoIC0gZnJhbWUuY2xpZW50V2lkdGggLSBmcmFtZS5zY3JvbGxMZWZ0KTtcbiAgICAgICAgY29uc3QgbW92ZVkgPSBjbGFtcChkaWZmWSwgLWZyYW1lLnNjcm9sbFRvcCwgZnJhbWUuc2Nyb2xsSGVpZ2h0IC0gZnJhbWUuY2xpZW50SGVpZ2h0IC0gZnJhbWUuc2Nyb2xsVG9wKTtcbiAgICAgICAgYWN0aW9ucy5wdXNoKFtcbiAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgeyBsZWZ0OiBmcmFtZS5zY3JvbGxMZWZ0ICsgbW92ZVgsIHRvcDogZnJhbWUuc2Nyb2xsVG9wICsgbW92ZVksIGJlaGF2aW9yOiBvcHRpb25zLmJlaGF2aW9yIH0sXG4gICAgICAgIF0pO1xuICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AgLSBtb3ZlWSwgZnJhbWVUb3ApO1xuICAgICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0IC0gbW92ZVgsIGZyYW1lUmlnaHQpO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20gLSBtb3ZlWSwgZnJhbWVCb3R0b20pO1xuICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCAtIG1vdmVYLCBmcmFtZUxlZnQpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9ucztcbn07XG5leHBvcnQgY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAoZWxlbWVudCwgc2Nyb2xsSW50b1ZpZXdPcHRpb25zLCBjb25maWcpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gc2Nyb2xsSW50b1ZpZXdPcHRpb25zIHx8IHt9O1xuICAgIGlmICghY2hlY2tCZWhhdmlvcihvcHRpb25zLmJlaGF2aW9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZhaWxlZEV4ZWN1dGVJbnZhbGlkRW51bVZhbHVlKFwic2Nyb2xsSW50b1ZpZXdcIiwgXCJFbGVtZW50XCIsIG9wdGlvbnMuYmVoYXZpb3IpKTtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9ucyA9IGNvbXB1dGVTY3JvbGxJbnRvVmlldyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICBhY3Rpb25zLmZvckVhY2goKFtmcmFtZSwgc2Nyb2xsVG9PcHRpb25zXSkgPT4ge1xuICAgICAgICBlbGVtZW50U2Nyb2xsKGZyYW1lLCBzY3JvbGxUb09wdGlvbnMsIGNvbmZpZyk7XG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IGVsZW1lbnRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsSW50b1ZpZXcuanMubWFwIiwiaW1wb3J0IHsgZWxlbWVudFNjcm9sbEludG9WaWV3IH0gZnJvbSBcInNlYW1sZXNzLXNjcm9sbC1wb2x5ZmlsbFwiO1xyXG5cclxuY29uc3Qgc21vdGhTY3JvbGwgPSAoKSA9PiB7XHJcbiAgIGNvbnN0IGdldE5hdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51LWxpc3QnKTtcclxuICAgY29uc3QgbWFpblNjcm9sbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX19zY3JvbGwnKTtcclxuXHJcbiAgIGNvbnN0IGdvU2VjdGlvbiA9IHRhcmdldCA9PiB7XHJcbiAgICAgIGNvbnN0IGdldElkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaHJlZicpLnNsaWNlKDEpO1xyXG4gICAgICBjb25zdCBnZXRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ2V0SWQpO1xyXG4gICAgICBpZiAoZ2V0U2VjdGlvbikge1xyXG4gICAgICAgICBlbGVtZW50U2Nyb2xsSW50b1ZpZXcoZ2V0U2VjdGlvbiwgeyBiZWhhdmlvcjogXCJzbW9vdGhcIiwgYmxvY2s6IFwiY2VudGVyXCIsIGlubGluZTogXCJjZW50ZXJcIiB9KTtcclxuICAgICAgfVxyXG4gICB9O1xyXG4gICBjb25zdCBhY3RpdmVMaW5rID0gKGUpID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcubWVudS1saXN0X19pdGVtJykpIHtcclxuICAgICAgICAgY29uc3QgZ2V0UGFyZW50ID0gdGFyZ2V0LmNsb3Nlc3QoJy5tZW51LWxpc3RfX2l0ZW0nKTtcclxuICAgICAgICAgY29uc3QgZ2V0TGluayA9IGdldFBhcmVudC5xdWVyeVNlbGVjdG9yKCcubWVudS1saXN0X19saW5rJyk7XHJcbiAgICAgICAgIGdvU2VjdGlvbihnZXRMaW5rKTtcclxuICAgICAgfVxyXG4gICB9O1xyXG5cclxuICAgZ2V0TmF2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYWN0aXZlTGluayk7XHJcbiAgIG1haW5TY3JvbGwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBnb1NlY3Rpb24obWFpblNjcm9sbCk7XHJcbiAgIH0pO1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBzbW90aFNjcm9sbDsiLCJjb25zdCB0YWJzID0gKCkgPT4ge1xyXG4gICBjb25zdCBkZXNpZ25MaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRlc2lnbi1saXN0Jyk7XHJcbiAgIGNvbnN0IGdldFRhYnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzaWduLWxpc3RfX2l0ZW0nKTtcclxuICAgY29uc3QgdGFic0Rlc2NyaXB0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlc2lnbl9fZGVzY3InKTtcclxuICAgY29uc3QgZGVzaWduQmxvY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzaWduLWJsb2NrID4gaW1nJyk7XHJcbiAgIGNvbnN0IGRlc2lnbkltZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZXNpZ24taW1hZ2VzJyk7XHJcblxyXG4gICBsZXQgYWN0aXZlVGFyZ2V0ID0gJyc7XHJcblxyXG4gICBjb25zdCBhY3RpdmVUYWIgPSBlID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgY29uc3QgYWN0aXZlQmxvY2sgPSBzZWxlY3RvciA9PiB7XHJcbiAgICAgICAgIHNlbGVjdG9yLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGl0ZW0uZGF0YXNldC50YWJzRmllbGQgPT09IGFjdGl2ZVRhcmdldCA/XHJcbiAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJykgOlxyXG4gICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZGVzaWduLWxpc3RfX2l0ZW0nKSAmJiAhdGFyZ2V0LmNsb3Nlc3QoJy5kZXNpZ24tbGlzdF9faXRlbV9hY3RpdmUnKSkge1xyXG4gICAgICAgICBnZXRUYWJzLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2Rlc2lnbi1saXN0X19pdGVtX2FjdGl2ZScpKTtcclxuICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2Rlc2lnbi1saXN0X19pdGVtX2FjdGl2ZScpO1xyXG4gICAgICAgICBhY3RpdmVUYXJnZXQgPSB0YXJnZXQuZGF0YXNldC50YWJzSGFuZGxlcjtcclxuICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpLnRleHRDb250ZW50ID0gYNCf0L7RgNGC0YTQvtC70LjQvjogJHt0YXJnZXQudGV4dENvbnRlbnR9YDtcclxuICAgICAgICAgYWN0aXZlQmxvY2sodGFic0Rlc2NyaXB0aW9uKTtcclxuICAgICAgICAgYWN0aXZlQmxvY2soZGVzaWduSW1nKTtcclxuICAgICAgICAgYWN0aXZlQmxvY2soZGVzaWduQmxvY2spO1xyXG4gICAgICB9XHJcbiAgIH07XHJcblxyXG4gICBkZXNpZ25MaXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYWN0aXZlVGFiKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHRhYnM7IiwiaW1wb3J0IGNoZWNrRm9ybSBmcm9tIFwiLi9jaGVja0Zvcm0uanNcIjtcclxuXHJcbmNvbnN0IG1haW5Gb3JtID0gKCkgPT4ge1xyXG4gICBjb25zdCBmb3JtQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm1fX2J1dHRvbicpO1xyXG4gICBjb25zdCBmb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvcm0tdGVzdC1kcml2ZScpO1xyXG4gICBjb25zdCBnZXRJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9ybS10ZXN0LWRyaXZlID4gaW5wdXQnKTtcclxuXHJcbiAgIGNvbnN0IHNlbmRGb3JtID0gYXN5bmMgZSA9PiB7XHJcbiAgICAgIGF3YWl0IGNvbnNvbGUubG9nKGNoZWNrRm9ybShlLCBmb3JtLCBbLi4uZ2V0SW5wdXRzXSkpO1xyXG4gICB9O1xyXG4gICBmb3JtQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VuZEZvcm0pO1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBtYWluRm9ybTsiLCJpbXBvcnQgYWNjb3JkZW9uIGZyb20gXCIuL21vZHVsZXMvYWNjb3JkZW9uXCI7XHJcbmltcG9ydCBjb3VudFRpbWVyIGZyb20gXCIuL21vZHVsZXMvY291bnRUaW1lclwiO1xyXG5pbXBvcnQgbWVudSBmcm9tIFwiLi9tb2R1bGVzL21lbnVcIjtcclxuaW1wb3J0IG1vZGFsIGZyb20gXCIuL21vZHVsZXMvbW9kYWxcIjtcclxuaW1wb3J0IHNtb3RoU2Nyb2xsIGZyb20gXCIuL21vZHVsZXMvc21vdGhTY3JvbGxcIjtcclxuaW1wb3J0IHRhYnMgZnJvbSBcIi4vbW9kdWxlcy90YWJzXCI7XHJcbmltcG9ydCBtYWluRm9ybSBmcm9tIFwiLi9tb2R1bGVzL21haW5Gb3JtXCI7XHJcblxyXG50YWJzKCk7XHJcbm1lbnUoKTtcclxuc21vdGhTY3JvbGwoKTtcclxuYWNjb3JkZW9uKCk7XHJcbmNvdW50VGltZXIoJzMxIG1hcmNoIDIwMjInKTtcclxubW9kYWwoKTtcclxubWFpbkZvcm0oKTtcclxuXHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWN0cycpLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAnMTAwcHgnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///240\n")}},__webpack_exports__={};__webpack_modules__[240]()})();