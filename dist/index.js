(()=>{"use strict";var __webpack_modules__={240:()=>{eval("\n;// CONCATENATED MODULE: ./src/modules/accordeon.js\nconst accordeon = () => {\r\n   const featureList = document.querySelector('.feature-list');\r\n   const featureLinks = document.querySelectorAll('.feature__link');\r\n   const featureSubs = document.querySelectorAll('.feature-sub');\r\n\r\n   const activeItem = e => {\r\n      e.preventDefault();\r\n      const target = e.target;\r\n      if (target.closest('.feature__link') && !target.closest('.feature__link_active')) {\r\n         const getParent = target.closest('.feature__link').parentNode;\r\n         const getLink = getParent.querySelector('.feature__link');\r\n         const getSub = getParent.querySelector('.feature-sub');\r\n         featureLinks.forEach(item => item.classList.remove('feature__link_active'));\r\n         featureSubs.forEach(item => item.classList.add('hidden'));\r\n         getLink.classList.add('feature__link_active');\r\n         getSub.classList.remove('hidden');\r\n      }\r\n   };\r\n\r\n   featureList.addEventListener('click', activeItem);\r\n};\r\n\r\n/* harmony default export */ const modules_accordeon = (accordeon);\n;// CONCATENATED MODULE: ./src/modules/countTimer.js\nconst countTimer = deadline => {\r\n\r\n   const getTimer = document.querySelector('.timer__time');\r\n\r\n   const getTimeRemaining = () => {\r\n      const dateStop = new Date(deadline),\r\n         dateNow = new Date().getTime(),\r\n         timerRemaining = (dateStop - dateNow) / 1000,\r\n         seconds = Math.floor(timerRemaining % 60),\r\n         minutes = Math.floor((timerRemaining / 60) % 60),\r\n         hours = Math.floor(timerRemaining / 60 / 60);\r\n      return { timerRemaining, hours, minutes, seconds };\r\n   };\r\n   const addZero = num => {\r\n      if (num >= 0 && num <= 9) {\r\n         return `0${num}`;\r\n      } else {\r\n         return num;\r\n      }\r\n   };\r\n   const updateClock = () => {\r\n      const timer = getTimeRemaining();\r\n      if (timer.timerRemaining > 0) {\r\n         getTimer.innerHTML = `${addZero(timer.hours)}:${addZero(timer.minutes)}:${addZero(timer.seconds)}`;\r\n      } else {\r\n         getTimer.textContent = `${'00:00:00'}`;\r\n         clearInterval(idInterval);\r\n      }\r\n   };\r\n   const idInterval = setInterval(updateClock, 1000);\r\n   updateClock();\r\n};\r\n\r\n/* harmony default export */ const modules_countTimer = (countTimer);\r\n\n;// CONCATENATED MODULE: ./src/modules/menu.js\nconst menu = () => {\r\n   const humburgerMenu = document.querySelector('.humburger-menu');\r\n   const menu = document.querySelector('.menu');\r\n\r\n   const openMenu = () => {\r\n      menu.style.top = '0';\r\n      document.addEventListener('click', closeMenu);\r\n   };\r\n   const closeMenu = e => {\r\n      if (!e.target.closest('.menu-list') && !e.target.closest('.humburger-menu') || e.target.closest('.menu-list__item')) {\r\n         menu.style.top = '-300px';\r\n         document.removeEventListener('click', closeMenu);\r\n      }\r\n   };\r\n   humburgerMenu.addEventListener('click', openMenu);\r\n};\r\n\r\n/* harmony default export */ const modules_menu = (menu);\n;// CONCATENATED MODULE: ./src/modules/blockScrolled.js\nconst disableScroll = () => {\r\n   document.body.dataset.scrollY = window.scrollY;\r\n\r\n   const scrollWidth = window.innerWidth - document.body.offsetWidth;\r\n\r\n   document.body.style.cssText = `\r\n      position: fixed;\r\n      top: -${window.scrollY}px;\r\n      left: 0;\r\n      width: 100%;\r\n      overflow: hidden;\r\n      height: 100vh;\r\n      padding-right: ${scrollWidth}px;\r\n   `;\r\n};\r\nconst enableScroll = () => {\r\n   document.body.style.cssText = '';\r\n   window.scroll({\r\n      top: document.body.dataset.scrollY\r\n   });\r\n};\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./src/modules/postData.js\nconst postData = async cart => {\r\n   try {\r\n      const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\r\n         method: 'POST',\r\n         body: JSON.stringify(cart),\r\n         headers: {\r\n            'Content-type': 'application/json; charset=UTF-8',\r\n         },\r\n      });\r\n      const resp = await response.json();\r\n      return resp;\r\n   } catch (err) {\r\n      console.error(err);\r\n   }\r\n};\r\n\r\n/* harmony default export */ const modules_postData = (postData);\r\n\n;// CONCATENATED MODULE: ./src/modules/clearForm.js\nconst clearForm = (inputs, sendMessage, modal) => {\r\n   inputs.forEach(item => item.value = '');\r\n   sendMessage ? sendMessage.remove() : false;\r\n   modal ? modal() : false;\r\n};\r\n/* harmony default export */ const modules_clearForm = (clearForm);\n;// CONCATENATED MODULE: ./src/modules/checkForm.js\n\r\n\r\n\r\nconst checkForm = async (e, form, inputs, modal) => {\r\n   e.preventDefault();\r\n   let orderMessage = document.querySelector('.order-message');\r\n   if (!orderMessage) {\r\n      const addMessage = `<span class=\"order-message\"><span>`;\r\n      form.insertAdjacentHTML('beforeEnd', addMessage);\r\n      orderMessage = document.querySelector('.order-message');\r\n      orderMessage.style.display = \"block\";\r\n      orderMessage.style.textAlign = \"center\";\r\n      orderMessage.style.fontSize = \"20px\";\r\n      orderMessage.style.padding = \"25px\";\r\n   }\r\n   const checkInput = () => {\r\n      return inputs.every(item => item.value !== '');\r\n   };\r\n   if (checkInput()) {\r\n      await modules_postData();\r\n      orderMessage.classList.add('active');\r\n      orderMessage.textContent = `Заявка успешно отправлена!`;\r\n      setTimeout(() => {\r\n         modules_clearForm(inputs, orderMessage, modal);\r\n      }, 2000);\r\n   } else {\r\n      orderMessage.textContent = `Заполните все поля!`;\r\n      orderMessage.classList.add('active');\r\n   }\r\n};\r\n/* harmony default export */ const modules_checkForm = (checkForm);\n;// CONCATENATED MODULE: ./src/modules/modal.js\n\r\n\r\n\r\n\r\nconst modal = () => {\r\n   const getModal = document.querySelector('.modal');\r\n   const mainButton = document.querySelector('.main__button');\r\n   const modalInputs = document.querySelectorAll('.modal__input');\r\n   const form = document.querySelector('.modal__form');\r\n\r\n   const closeModal = () => {\r\n      getModal.classList.add('hidden');\r\n      enableScroll();\r\n   };\r\n   const sendForm = async e => {\r\n      await modules_checkForm(e, form, [...modalInputs], closeModal);\r\n   };\r\n   const controlModal = e => {\r\n      const target = e.target;\r\n      if (target.closest('.modal__close') || target.closest('.overlay')) {\r\n         const orderMessage = document.querySelector('.order-message');\r\n         modules_clearForm([...modalInputs], orderMessage, closeModal);\r\n      }\r\n      if (target.closest('.modal__button')) {\r\n         sendForm(e);\r\n      }\r\n   };\r\n   const openModal = e => {\r\n      e.preventDefault();\r\n      disableScroll();\r\n      getModal.classList.remove('hidden');\r\n      getModal.addEventListener('click', controlModal);\r\n   };\r\n\r\n   mainButton.addEventListener('click', openModal);\r\n};\r\n\r\n/* harmony default export */ const modules_modal = (modal);\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/common.js\nconst checkBehavior = (behavior) => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\nfunction elementScrollXY(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\nconst failedExecute = (method, object, reason = \"cannot convert to dictionary.\") => `Failed to execute '${method}' on '${object}': ${reason}`;\nconst failedExecuteInvalidEnumValue = (method, object, value) => failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n/* eslint-disable */\nconst backupMethod = (proto, method, fallback) => {\n    var _a;\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n    if (!proto[backup] && proto[method] && !((_a = proto[method]) === null || _a === void 0 ? void 0 : _a.__isPolyfill)) {\n        proto[backup] = proto[method];\n    }\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\nconst isObject = (value) => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\nconst isScrollBehaviorSupported = () => \"scrollBehavior\" in window.document.documentElement.style;\nconst markPolyfill = (method) => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\nconst modifyPrototypes = (prop, func) => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nconst scrollingElement = (element) => element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n//# sourceMappingURL=common.js.map\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/scroll-step.js\nconst ease = (k) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n/* eslint-disable */\nfunction now() {\n    var _a;\n    let fn;\n    if ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.now) {\n        fn = () => window.performance.now();\n    }\n    else {\n        fn = () => window.Date.now();\n    }\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\nconst DURATION = 500;\nconst step = (context) => {\n    const currentTime = now();\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n    context.method(currentX, currentY);\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n//# sourceMappingURL=scroll-step.js.map\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/scroll.js\n\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value) => {\n    if (!isFinite(value)) {\n        return 0;\n    }\n    return Number(value);\n};\nconst isConnected = (node) => {\n    var _a;\n    return ((_a = node.isConnected) !== null && _a !== void 0 ? _a : (!node.ownerDocument ||\n        // eslint-disable-next-line no-bitwise\n        !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1)));\n};\nconst scrollWithOptions = (element, options, config) => {\n    var _a, _b;\n    if (!isConnected(element)) {\n        return;\n    }\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n    const targetX = nonFinite((_a = options.left) !== null && _a !== void 0 ? _a : startX);\n    const targetY = nonFinite((_b = options.top) !== null && _b !== void 0 ? _b : startY);\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element), \"scroll\", fallback).bind(element);\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n    const context = Object.assign(Object.assign({}, config), { timeStamp: now(), startX,\n        startY,\n        targetX,\n        targetY, rafId: 0, method, callback: removeEventListener });\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    step(context);\n};\nconst isWindow = (obj) => obj.window === obj;\nconst createScroll = (scrollName) => (target, scrollOptions, config) => {\n    const [element, scrollType] = isWindow(target)\n        ? [scrollingElement(target.document.documentElement), \"Window\"]\n        : [target, \"Element\"];\n    const options = scrollOptions !== null && scrollOptions !== void 0 ? scrollOptions : {};\n    if (!isObject(options)) {\n        throw new TypeError(failedExecute(scrollName, scrollType));\n    }\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n    }\n    if (scrollName === \"scrollBy\") {\n        options.left = nonFinite(options.left) + element.scrollLeft;\n        options.top = nonFinite(options.top) + element.scrollTop;\n    }\n    scrollWithOptions(element, options, config);\n};\nconst scroll_scroll = /* #__PURE__ */ createScroll(\"scroll\");\nconst scrollTo = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollTo\")));\nconst scrollBy = /* #__PURE__ */ (/* unused pure expression or super */ null && (createScroll(\"scrollBy\")));\nconst elementScroll = scroll_scroll;\nconst elementScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst elementScrollBy = (/* unused pure expression or super */ null && (scrollBy));\nconst windowScroll = (/* unused pure expression or super */ null && (scroll_scroll));\nconst windowScrollTo = (/* unused pure expression or super */ null && (scrollTo));\nconst windowScrollBy = (/* unused pure expression or super */ null && (scrollBy));\n//# sourceMappingURL=scroll.js.map\n;// CONCATENATED MODULE: ./node_modules/seamless-scroll-polyfill/lib/scrollIntoView.js\n/* eslint-disable no-bitwise */\n\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode) => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return 0 /* HorizontalTb */;\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return 1 /* VerticalRl */;\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return 2 /* VerticalLr */;\n        case \"sideways-rl\":\n            return 3 /* SidewaysRl */;\n        case \"sideways-lr\":\n            return 4 /* SidewaysLr */;\n    }\n    return 0 /* HorizontalTb */;\n};\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= 2 /* ReverseVertical */;\n    }\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case 0 /* HorizontalTb */:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case 1 /* VerticalRl */:\n        case 3 /* SidewaysRl */:\n            //  reverse horizontal\n            layout ^= 1 /* ReverseHorizontal */;\n            break;\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case 4 /* SidewaysLr */:\n            // reverse vertical\n            layout ^= 2 /* ReverseVertical */;\n            break;\n    }\n    return [layout, hPos, vPos];\n};\nconst isXReversed = (computedStyle) => {\n    const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n    return (layout & 1) === 1;\n};\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return 1 /* CenterAlways */;\n            case \"nearest\":\n                return 0 /* ToEdgeIfNeeded */;\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? 2 /* LeftOrTop */ : 3 /* RightOrBottom */;\n            }\n        }\n    });\n};\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n    if (align !== 0 /* ToEdgeIfNeeded */) {\n        return align;\n    }\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n        return null;\n    }\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n        return 2 /* LeftOrTop */;\n    }\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n        return 3 /* RightOrBottom */;\n    }\n    return null;\n};\nconst canOverflow = (overflow) => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\nconst getFrameElement = (element) => {\n    var _a;\n    try {\n        return ((_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement) || null;\n    }\n    catch (_b) {\n        return null;\n    }\n};\nconst isScrollable = (element, computedStyle) => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element));\n    }\n    return false;\n};\nconst parentElement = (element) => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return pNode.host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n    return pElement;\n};\nconst clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\nconst getSupportedScrollMarginProperty = (ownerDocument) => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return [\"scroll-margin\", \"scroll-snap-margin\"].filter((property) => property in ownerDocument.documentElement.style)[0];\n};\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n    const scrollMarginValue = (edge) => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\nconst calcAlignEdge = (align, start, end) => {\n    switch (align) {\n        case 1 /* CenterAlways */:\n            return (start + end) / 2;\n        case 3 /* RightOrBottom */:\n            return end;\n        case 2 /* LeftOrTop */:\n        case 0 /* ToEdgeIfNeeded */:\n            return start;\n    }\n};\nconst getFrameViewport = (frame, frameRect) => {\n    var _a, _b, _c;\n    const visualViewport = (_a = frame.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.visualViewport;\n    const [x, y, width, height] = frame === scrollingElement(frame)\n        ? [0, 0, (_b = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _b !== void 0 ? _b : frame.clientWidth, (_c = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _c !== void 0 ? _c : frame.clientHeight]\n        : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n    return [top, right, bottom, left];\n};\nconst computeScrollIntoView = (element, options) => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions = [];\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n    if (!ownerWindow) {\n        return actions;\n    }\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n    const writingMode = normalizeWritingMode(computedStyle.writingMode ||\n        computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n        computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n        const frameRect = frame.getBoundingClientRect();\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n        const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n    return actions;\n};\nconst scrollIntoView = (element, scrollIntoViewOptions, config) => {\n    const options = scrollIntoViewOptions || {};\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n    const actions = computeScrollIntoView(element, options);\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\nconst elementScrollIntoView = scrollIntoView;\n//# sourceMappingURL=scrollIntoView.js.map\n;// CONCATENATED MODULE: ./src/modules/smothScroll.js\n\r\n\r\nconst smothScroll = () => {\r\n   const getNav = document.querySelector('.menu-list');\r\n   const mainScroll = document.querySelector('.main__scroll');\r\n\r\n   const goSection = target => {\r\n      const getId = target.getAttribute('href').slice(1);\r\n      const getSection = document.getElementById(getId);\r\n      if (getSection) {\r\n         elementScrollIntoView(getSection, { behavior: \"smooth\", block: \"center\", inline: \"center\" });\r\n      }\r\n   };\r\n   const activeLink = (e) => {\r\n      e.preventDefault();\r\n      const target = e.target;\r\n      if (target.closest('.menu-list__item')) {\r\n         const getParent = target.closest('.menu-list__item');\r\n         const getLink = getParent.querySelector('.menu-list__link');\r\n         goSection(getLink);\r\n      }\r\n   };\r\n\r\n   getNav.addEventListener('click', activeLink);\r\n   mainScroll.addEventListener('click', e => {\r\n      e.preventDefault();\r\n      goSection(mainScroll);\r\n   });\r\n};\r\n/* harmony default export */ const modules_smothScroll = (smothScroll);\n;// CONCATENATED MODULE: ./src/modules/tabs.js\nconst tabs = () => {\r\n   const designList = document.querySelector('.design-list');\r\n   const getTabs = document.querySelectorAll('.design-list__item');\r\n   const tabsDescription = document.querySelectorAll('.design__descr');\r\n   const designBlock = document.querySelectorAll('.design-block > img');\r\n   const designImg = document.querySelectorAll('.design-images');\r\n   const designTitle = document.querySelectorAll('.design__title');\r\n\r\n   let activeTarget = '';\r\n\r\n   const activeTab = e => {\r\n      e.preventDefault();\r\n      const target = e.target;\r\n      const activeBlock = selector => {\r\n         selector.forEach(item => {\r\n            item.dataset.tabsField === activeTarget ?\r\n               item.classList.remove('hidden') :\r\n               item.classList.add('hidden');\r\n         });\r\n      };\r\n      if (target.closest('.design-list__item') && !target.closest('.design-list__item_active')) {\r\n         getTabs.forEach(item => item.classList.remove('design-list__item_active'));\r\n         target.classList.add('design-list__item_active');\r\n         activeTarget = target.dataset.tabsHandler;\r\n         designTitle.forEach((item, index) => {\r\n            if (index === [...getTabs].indexOf(target)) {\r\n               item.classList.remove('hidden');\r\n               document.querySelector(\"title\").textContent = item.textContent;\r\n            } else {\r\n               item.classList.add('hidden');\r\n            }\r\n         });\r\n\r\n         activeBlock(tabsDescription);\r\n         activeBlock(designImg);\r\n         activeBlock(designBlock);\r\n      }\r\n   };\r\n\r\n   designList.addEventListener('click', activeTab);\r\n};\r\n\r\n/* harmony default export */ const modules_tabs = (tabs);\n;// CONCATENATED MODULE: ./src/modules/mainForm.js\n\r\n\r\nconst mainForm = () => {\r\n   const formButton = document.querySelector('.form__button');\r\n   const form = document.querySelector('.form-test-drive');\r\n   const getInputs = document.querySelectorAll('.form-test-drive > input');\r\n\r\n   const sendForm = async e => {\r\n      await console.log(modules_checkForm(e, form, [...getInputs]));\r\n   };\r\n   formButton.addEventListener('click', sendForm);\r\n};\r\n/* harmony default export */ const modules_mainForm = (mainForm);\n;// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmodules_tabs();\r\nmodules_menu();\r\nmodules_smothScroll();\r\nmodules_accordeon();\r\nmodules_countTimer('31 march 2022');\r\nmodules_modal();\r\nmodules_mainForm();\r\n\r\ndocument.getElementById('contacts').style.paddingBottom = '100px';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFlBQVk7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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cz80YTJmIiwid2VicGFjazovL3BvcnRmb2xpby8uL3NyYy9tb2R1bGVzL2NvdW50VGltZXIuanM/MGRmOCIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy9tZW51LmpzPzJmYWQiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvYmxvY2tTY3JvbGxlZC5qcz9hNDk2Iiwid2VicGFjazovL3BvcnRmb2xpby8uL3NyYy9tb2R1bGVzL3Bvc3REYXRhLmpzP2FlZTAiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvY2xlYXJGb3JtLmpzP2VlMDIiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvY2hlY2tGb3JtLmpzPzMzNWQiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvbW9kYWwuanM/OGJlNSIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsL2xpYi9jb21tb24uanM/ZTM1YyIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvc2VhbWxlc3Mtc2Nyb2xsLXBvbHlmaWxsL2xpYi9zY3JvbGwtc3RlcC5qcz9jMzIxIiwid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL3Njcm9sbC5qcz9kODFiIiwid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9zZWFtbGVzcy1zY3JvbGwtcG9seWZpbGwvbGliL3Njcm9sbEludG9WaWV3LmpzPzUyMTYiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvc21vdGhTY3JvbGwuanM/NmU3OSIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvbW9kdWxlcy90YWJzLmpzP2I3YjIiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vc3JjL21vZHVsZXMvbWFpbkZvcm0uanM/MjYyZiIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhY2NvcmRlb24gPSAoKSA9PiB7XHJcbiAgIGNvbnN0IGZlYXR1cmVMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZlYXR1cmUtbGlzdCcpO1xyXG4gICBjb25zdCBmZWF0dXJlTGlua3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmVhdHVyZV9fbGluaycpO1xyXG4gICBjb25zdCBmZWF0dXJlU3VicyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mZWF0dXJlLXN1YicpO1xyXG5cclxuICAgY29uc3QgYWN0aXZlSXRlbSA9IGUgPT4ge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgICBpZiAodGFyZ2V0LmNsb3Nlc3QoJy5mZWF0dXJlX19saW5rJykgJiYgIXRhcmdldC5jbG9zZXN0KCcuZmVhdHVyZV9fbGlua19hY3RpdmUnKSkge1xyXG4gICAgICAgICBjb25zdCBnZXRQYXJlbnQgPSB0YXJnZXQuY2xvc2VzdCgnLmZlYXR1cmVfX2xpbmsnKS5wYXJlbnROb2RlO1xyXG4gICAgICAgICBjb25zdCBnZXRMaW5rID0gZ2V0UGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5mZWF0dXJlX19saW5rJyk7XHJcbiAgICAgICAgIGNvbnN0IGdldFN1YiA9IGdldFBhcmVudC5xdWVyeVNlbGVjdG9yKCcuZmVhdHVyZS1zdWInKTtcclxuICAgICAgICAgZmVhdHVyZUxpbmtzLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2ZlYXR1cmVfX2xpbmtfYWN0aXZlJykpO1xyXG4gICAgICAgICBmZWF0dXJlU3Vicy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKSk7XHJcbiAgICAgICAgIGdldExpbmsuY2xhc3NMaXN0LmFkZCgnZmVhdHVyZV9fbGlua19hY3RpdmUnKTtcclxuICAgICAgICAgZ2V0U3ViLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICB9XHJcbiAgIH07XHJcblxyXG4gICBmZWF0dXJlTGlzdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFjdGl2ZUl0ZW0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWNjb3JkZW9uOyIsImNvbnN0IGNvdW50VGltZXIgPSBkZWFkbGluZSA9PiB7XHJcblxyXG4gICBjb25zdCBnZXRUaW1lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50aW1lcl9fdGltZScpO1xyXG5cclxuICAgY29uc3QgZ2V0VGltZVJlbWFpbmluZyA9ICgpID0+IHtcclxuICAgICAgY29uc3QgZGF0ZVN0b3AgPSBuZXcgRGF0ZShkZWFkbGluZSksXHJcbiAgICAgICAgIGRhdGVOb3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcclxuICAgICAgICAgdGltZXJSZW1haW5pbmcgPSAoZGF0ZVN0b3AgLSBkYXRlTm93KSAvIDEwMDAsXHJcbiAgICAgICAgIHNlY29uZHMgPSBNYXRoLmZsb29yKHRpbWVyUmVtYWluaW5nICUgNjApLFxyXG4gICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigodGltZXJSZW1haW5pbmcgLyA2MCkgJSA2MCksXHJcbiAgICAgICAgIGhvdXJzID0gTWF0aC5mbG9vcih0aW1lclJlbWFpbmluZyAvIDYwIC8gNjApO1xyXG4gICAgICByZXR1cm4geyB0aW1lclJlbWFpbmluZywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgfTtcclxuICAgfTtcclxuICAgY29uc3QgYWRkWmVybyA9IG51bSA9PiB7XHJcbiAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPD0gOSkge1xyXG4gICAgICAgICByZXR1cm4gYDAke251bX1gO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICByZXR1cm4gbnVtO1xyXG4gICAgICB9XHJcbiAgIH07XHJcbiAgIGNvbnN0IHVwZGF0ZUNsb2NrID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCB0aW1lciA9IGdldFRpbWVSZW1haW5pbmcoKTtcclxuICAgICAgaWYgKHRpbWVyLnRpbWVyUmVtYWluaW5nID4gMCkge1xyXG4gICAgICAgICBnZXRUaW1lci5pbm5lckhUTUwgPSBgJHthZGRaZXJvKHRpbWVyLmhvdXJzKX06JHthZGRaZXJvKHRpbWVyLm1pbnV0ZXMpfToke2FkZFplcm8odGltZXIuc2Vjb25kcyl9YDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgZ2V0VGltZXIudGV4dENvbnRlbnQgPSBgJHsnMDA6MDA6MDAnfWA7XHJcbiAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWRJbnRlcnZhbCk7XHJcbiAgICAgIH1cclxuICAgfTtcclxuICAgY29uc3QgaWRJbnRlcnZhbCA9IHNldEludGVydmFsKHVwZGF0ZUNsb2NrLCAxMDAwKTtcclxuICAgdXBkYXRlQ2xvY2soKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNvdW50VGltZXI7XHJcbiIsImNvbnN0IG1lbnUgPSAoKSA9PiB7XHJcbiAgIGNvbnN0IGh1bWJ1cmdlck1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaHVtYnVyZ2VyLW1lbnUnKTtcclxuICAgY29uc3QgbWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51Jyk7XHJcblxyXG4gICBjb25zdCBvcGVuTWVudSA9ICgpID0+IHtcclxuICAgICAgbWVudS5zdHlsZS50b3AgPSAnMCc7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2VNZW51KTtcclxuICAgfTtcclxuICAgY29uc3QgY2xvc2VNZW51ID0gZSA9PiB7XHJcbiAgICAgIGlmICghZS50YXJnZXQuY2xvc2VzdCgnLm1lbnUtbGlzdCcpICYmICFlLnRhcmdldC5jbG9zZXN0KCcuaHVtYnVyZ2VyLW1lbnUnKSB8fCBlLnRhcmdldC5jbG9zZXN0KCcubWVudS1saXN0X19pdGVtJykpIHtcclxuICAgICAgICAgbWVudS5zdHlsZS50b3AgPSAnLTMwMHB4JztcclxuICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbG9zZU1lbnUpO1xyXG4gICAgICB9XHJcbiAgIH07XHJcbiAgIGh1bWJ1cmdlck1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvcGVuTWVudSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtZW51OyIsImNvbnN0IGRpc2FibGVTY3JvbGwgPSAoKSA9PiB7XHJcbiAgIGRvY3VtZW50LmJvZHkuZGF0YXNldC5zY3JvbGxZID0gd2luZG93LnNjcm9sbFk7XHJcblxyXG4gICBjb25zdCBzY3JvbGxXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcclxuXHJcbiAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3NzVGV4dCA9IGBcclxuICAgICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgICB0b3A6IC0ke3dpbmRvdy5zY3JvbGxZfXB4O1xyXG4gICAgICBsZWZ0OiAwO1xyXG4gICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgaGVpZ2h0OiAxMDB2aDtcclxuICAgICAgcGFkZGluZy1yaWdodDogJHtzY3JvbGxXaWR0aH1weDtcclxuICAgYDtcclxufTtcclxuY29uc3QgZW5hYmxlU2Nyb2xsID0gKCkgPT4ge1xyXG4gICBkb2N1bWVudC5ib2R5LnN0eWxlLmNzc1RleHQgPSAnJztcclxuICAgd2luZG93LnNjcm9sbCh7XHJcbiAgICAgIHRvcDogZG9jdW1lbnQuYm9keS5kYXRhc2V0LnNjcm9sbFlcclxuICAgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgeyBkaXNhYmxlU2Nyb2xsLCBlbmFibGVTY3JvbGwgfTtcclxuIiwiY29uc3QgcG9zdERhdGEgPSBhc3luYyBjYXJ0ID0+IHtcclxuICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9qc29ucGxhY2Vob2xkZXIudHlwaWNvZGUuY29tL3Bvc3RzJywge1xyXG4gICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2FydCksXHJcbiAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04JyxcclxuICAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIHJldHVybiByZXNwO1xyXG4gICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwb3N0RGF0YTtcclxuIiwiY29uc3QgY2xlYXJGb3JtID0gKGlucHV0cywgc2VuZE1lc3NhZ2UsIG1vZGFsKSA9PiB7XHJcbiAgIGlucHV0cy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS52YWx1ZSA9ICcnKTtcclxuICAgc2VuZE1lc3NhZ2UgPyBzZW5kTWVzc2FnZS5yZW1vdmUoKSA6IGZhbHNlO1xyXG4gICBtb2RhbCA/IG1vZGFsKCkgOiBmYWxzZTtcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgY2xlYXJGb3JtOyIsImltcG9ydCBwb3N0RGF0YSBmcm9tIFwiLi9wb3N0RGF0YS5qc1wiO1xyXG5pbXBvcnQgY2xlYXJGb3JtIGZyb20gXCIuL2NsZWFyRm9ybS5qc1wiO1xyXG5cclxuY29uc3QgY2hlY2tGb3JtID0gYXN5bmMgKGUsIGZvcm0sIGlucHV0cywgbW9kYWwpID0+IHtcclxuICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICBsZXQgb3JkZXJNZXNzYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9yZGVyLW1lc3NhZ2UnKTtcclxuICAgaWYgKCFvcmRlck1lc3NhZ2UpIHtcclxuICAgICAgY29uc3QgYWRkTWVzc2FnZSA9IGA8c3BhbiBjbGFzcz1cIm9yZGVyLW1lc3NhZ2VcIj48c3Bhbj5gO1xyXG4gICAgICBmb3JtLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlRW5kJywgYWRkTWVzc2FnZSk7XHJcbiAgICAgIG9yZGVyTWVzc2FnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcmRlci1tZXNzYWdlJyk7XHJcbiAgICAgIG9yZGVyTWVzc2FnZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICBvcmRlck1lc3NhZ2Uuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgb3JkZXJNZXNzYWdlLnN0eWxlLmZvbnRTaXplID0gXCIyMHB4XCI7XHJcbiAgICAgIG9yZGVyTWVzc2FnZS5zdHlsZS5wYWRkaW5nID0gXCIyNXB4XCI7XHJcbiAgIH1cclxuICAgY29uc3QgY2hlY2tJbnB1dCA9ICgpID0+IHtcclxuICAgICAgcmV0dXJuIGlucHV0cy5ldmVyeShpdGVtID0+IGl0ZW0udmFsdWUgIT09ICcnKTtcclxuICAgfTtcclxuICAgaWYgKGNoZWNrSW5wdXQoKSkge1xyXG4gICAgICBhd2FpdCBwb3N0RGF0YSgpO1xyXG4gICAgICBvcmRlck1lc3NhZ2UuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgICAgIG9yZGVyTWVzc2FnZS50ZXh0Q29udGVudCA9IGDQl9Cw0Y/QstC60LAg0YPRgdC/0LXRiNC90L4g0L7RgtC/0YDQsNCy0LvQtdC90LAhYDtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgIGNsZWFyRm9ybShpbnB1dHMsIG9yZGVyTWVzc2FnZSwgbW9kYWwpO1xyXG4gICAgICB9LCAyMDAwKTtcclxuICAgfSBlbHNlIHtcclxuICAgICAgb3JkZXJNZXNzYWdlLnRleHRDb250ZW50ID0gYNCX0LDQv9C+0LvQvdC40YLQtSDQstGB0LUg0L/QvtC70Y8hYDtcclxuICAgICAgb3JkZXJNZXNzYWdlLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG4gICB9XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IGNoZWNrRm9ybTsiLCJpbXBvcnQgeyBkaXNhYmxlU2Nyb2xsLCBlbmFibGVTY3JvbGwgfSBmcm9tIFwiLi9ibG9ja1Njcm9sbGVkLmpzXCI7XHJcbmltcG9ydCBjaGVja0Zvcm0gZnJvbSBcIi4vY2hlY2tGb3JtLmpzXCI7XHJcbmltcG9ydCBjbGVhckZvcm0gZnJvbSBcIi4vY2xlYXJGb3JtLmpzXCI7XHJcblxyXG5jb25zdCBtb2RhbCA9ICgpID0+IHtcclxuICAgY29uc3QgZ2V0TW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwnKTtcclxuICAgY29uc3QgbWFpbkJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluX19idXR0b24nKTtcclxuICAgY29uc3QgbW9kYWxJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9kYWxfX2lucHV0Jyk7XHJcbiAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWxfX2Zvcm0nKTtcclxuXHJcbiAgIGNvbnN0IGNsb3NlTW9kYWwgPSAoKSA9PiB7XHJcbiAgICAgIGdldE1vZGFsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICBlbmFibGVTY3JvbGwoKTtcclxuICAgfTtcclxuICAgY29uc3Qgc2VuZEZvcm0gPSBhc3luYyBlID0+IHtcclxuICAgICAgYXdhaXQgY2hlY2tGb3JtKGUsIGZvcm0sIFsuLi5tb2RhbElucHV0c10sIGNsb3NlTW9kYWwpO1xyXG4gICB9O1xyXG4gICBjb25zdCBjb250cm9sTW9kYWwgPSBlID0+IHtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLm1vZGFsX19jbG9zZScpIHx8IHRhcmdldC5jbG9zZXN0KCcub3ZlcmxheScpKSB7XHJcbiAgICAgICAgIGNvbnN0IG9yZGVyTWVzc2FnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcmRlci1tZXNzYWdlJyk7XHJcbiAgICAgICAgIGNsZWFyRm9ybShbLi4ubW9kYWxJbnB1dHNdLCBvcmRlck1lc3NhZ2UsIGNsb3NlTW9kYWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLm1vZGFsX19idXR0b24nKSkge1xyXG4gICAgICAgICBzZW5kRm9ybShlKTtcclxuICAgICAgfVxyXG4gICB9O1xyXG4gICBjb25zdCBvcGVuTW9kYWwgPSBlID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBkaXNhYmxlU2Nyb2xsKCk7XHJcbiAgICAgIGdldE1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICBnZXRNb2RhbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNvbnRyb2xNb2RhbCk7XHJcbiAgIH07XHJcblxyXG4gICBtYWluQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb3Blbk1vZGFsKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG1vZGFsOyIsImV4cG9ydCBjb25zdCBjaGVja0JlaGF2aW9yID0gKGJlaGF2aW9yKSA9PiB7XG4gICAgcmV0dXJuIGJlaGF2aW9yID09PSB1bmRlZmluZWQgfHwgYmVoYXZpb3IgPT09IFwiYXV0b1wiIHx8IGJlaGF2aW9yID09PSBcImluc3RhbnRcIiB8fCBiZWhhdmlvciA9PT0gXCJzbW9vdGhcIjtcbn07XG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudFNjcm9sbFhZKHgsIHkpIHtcbiAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbn1cbmV4cG9ydCBjb25zdCBmYWlsZWRFeGVjdXRlID0gKG1ldGhvZCwgb2JqZWN0LCByZWFzb24gPSBcImNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuXCIpID0+IGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHttZXRob2R9JyBvbiAnJHtvYmplY3R9JzogJHtyZWFzb259YDtcbmV4cG9ydCBjb25zdCBmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZSA9IChtZXRob2QsIG9iamVjdCwgdmFsdWUpID0+IGZhaWxlZEV4ZWN1dGUobWV0aG9kLCBvYmplY3QsIGBUaGUgcHJvdmlkZWQgdmFsdWUgJyR7dmFsdWV9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgU2Nyb2xsQmVoYXZpb3IuYCk7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IGJhY2t1cE1ldGhvZCA9IChwcm90bywgbWV0aG9kLCBmYWxsYmFjaykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBiYWNrdXAgPSBgX19TRUFNTEVTUy5CQUNLVVAkJHttZXRob2R9YDtcbiAgICBpZiAoIXByb3RvW2JhY2t1cF0gJiYgcHJvdG9bbWV0aG9kXSAmJiAhKChfYSA9IHByb3RvW21ldGhvZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fX2lzUG9seWZpbGwpKSB7XG4gICAgICAgIHByb3RvW2JhY2t1cF0gPSBwcm90b1ttZXRob2RdO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG9bYmFja3VwXSB8fCBmYWxsYmFjaztcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlID09PSBcImZ1bmN0aW9uXCIpO1xufTtcbmV4cG9ydCBjb25zdCBpc1Njcm9sbEJlaGF2aW9yU3VwcG9ydGVkID0gKCkgPT4gXCJzY3JvbGxCZWhhdmlvclwiIGluIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5leHBvcnQgY29uc3QgbWFya1BvbHlmaWxsID0gKG1ldGhvZCkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiX19pc1BvbHlmaWxsXCIsIHsgdmFsdWU6IHRydWUgfSk7XG59O1xuZXhwb3J0IGNvbnN0IG1vZGlmeVByb3RvdHlwZXMgPSAocHJvcCwgZnVuYykgPT4ge1xuICAgIG1hcmtQb2x5ZmlsbChmdW5jKTtcbiAgICBbSFRNTEVsZW1lbnQucHJvdG90eXBlLCBTVkdFbGVtZW50LnByb3RvdHlwZSwgRWxlbWVudC5wcm90b3R5cGVdLmZvckVhY2goKHByb3RvdHlwZSkgPT4ge1xuICAgICAgICBiYWNrdXBNZXRob2QocHJvdG90eXBlLCBwcm9wKTtcbiAgICAgICAgcHJvdG90eXBlW3Byb3BdID0gZnVuYztcbiAgICB9KTtcbn07XG4vKipcbiAqIC0gT24gQ2hyb21lIGFuZCBGaXJlZm94LCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHdpbGwgcmV0dXJuIHRoZSA8aHRtbD4gZWxlbWVudC5cbiAqIC0gU2FmYXJpLCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHdpbGwgcmV0dXJuIHRoZSA8Ym9keT4gZWxlbWVudC5cbiAqIC0gT24gRWRnZSwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB3aWxsIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuXG4gKiAtIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LCBidXQgeW91IGNhbiBhc3N1bWUgaXRzIDxodG1sPi5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCJjb25zdCBlYXNlID0gKGspID0+IHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xufTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm47XG4gICAgaWYgKChfYSA9IHdpbmRvdy5wZXJmb3JtYW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vdykge1xuICAgICAgICBmbiA9ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZuID0gKCkgPT4gd2luZG93LkRhdGUubm93KCk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBub3cgPSBmbjtcbiAgICByZXR1cm4gZm4oKTtcbn1cbi8qIGVzbGludC1lbmFibGUgKi9cbmNvbnN0IERVUkFUSU9OID0gNTAwO1xuZXhwb3J0IGNvbnN0IHN0ZXAgPSAoY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IChjdXJyZW50VGltZSAtIGNvbnRleHQudGltZVN0YW1wKSAvIChjb250ZXh0LmR1cmF0aW9uIHx8IERVUkFUSU9OKTtcbiAgICBpZiAoZWxhcHNlZCA+IDEpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QoY29udGV4dC50YXJnZXRYLCBjb250ZXh0LnRhcmdldFkpO1xuICAgICAgICBjb250ZXh0LmNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSAoY29udGV4dC50aW1pbmdGdW5jIHx8IGVhc2UpKGVsYXBzZWQpO1xuICAgIGNvbnN0IGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC50YXJnZXRYIC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgY29uc3QgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnRhcmdldFkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcbiAgICBjb250ZXh0Lm1ldGhvZChjdXJyZW50WCwgY3VycmVudFkpO1xuICAgIGNvbnRleHQucmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc3RlcChjb250ZXh0KTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JvbGwtc3RlcC5qcy5tYXAiLCJpbXBvcnQgeyBiYWNrdXBNZXRob2QsIGNoZWNrQmVoYXZpb3IsIGVsZW1lbnRTY3JvbGxYWSwgZmFpbGVkRXhlY3V0ZSwgZmFpbGVkRXhlY3V0ZUludmFsaWRFbnVtVmFsdWUsIGlzT2JqZWN0LCBzY3JvbGxpbmdFbGVtZW50LCB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgbm93LCBzdGVwIH0gZnJvbSBcIi4vc2Nyb2xsLXN0ZXAuanNcIjtcbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNub3JtYWxpemUtbm9uLWZpbml0ZS12YWx1ZXNcbmNvbnN0IG5vbkZpbml0ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbn07XG5jb25zdCBpc0Nvbm5lY3RlZCA9IChub2RlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gbm9kZS5pc0Nvbm5lY3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCFub2RlLm93bmVyRG9jdW1lbnQgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgIShub2RlLm93bmVyRG9jdW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAvKiogRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEICovIDEpKSk7XG59O1xuY29uc3Qgc2Nyb2xsV2l0aE9wdGlvbnMgPSAoZWxlbWVudCwgb3B0aW9ucywgY29uZmlnKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIWlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRYID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IHN0YXJ0WSA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IHRhcmdldFggPSBub25GaW5pdGUoKF9hID0gb3B0aW9ucy5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGFydFgpO1xuICAgIGNvbnN0IHRhcmdldFkgPSBub25GaW5pdGUoKF9iID0gb3B0aW9ucy50b3ApICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHN0YXJ0WSk7XG4gICAgaWYgKHRhcmdldFggPT09IHN0YXJ0WCAmJiB0YXJnZXRZID09PSBzdGFydFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmYWxsYmFjayA9IGJhY2t1cE1ldGhvZChIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwic2Nyb2xsXCIsIGVsZW1lbnRTY3JvbGxYWSk7XG4gICAgY29uc3QgbWV0aG9kID0gYmFja3VwTWV0aG9kKE9iamVjdC5nZXRQcm90b3R5cGVPZihlbGVtZW50KSwgXCJzY3JvbGxcIiwgZmFsbGJhY2spLmJpbmQoZWxlbWVudCk7XG4gICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgIT09IFwic21vb3RoXCIpIHtcbiAgICAgICAgbWV0aG9kKHRhcmdldFgsIHRhcmdldFkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgY2FuY2VsU2Nyb2xsKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgY2FuY2VsU2Nyb2xsKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgdGltZVN0YW1wOiBub3coKSwgc3RhcnRYLFxuICAgICAgICBzdGFydFksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksIHJhZklkOiAwLCBtZXRob2QsIGNhbGxiYWNrOiByZW1vdmVFdmVudExpc3RlbmVyIH0pO1xuICAgIGNvbnN0IGNhbmNlbFNjcm9sbCA9ICgpID0+IHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGNvbnRleHQucmFmSWQpO1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGNhbmNlbFNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICBvbmNlOiB0cnVlLFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGNhbmNlbFNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICBvbmNlOiB0cnVlLFxuICAgIH0pO1xuICAgIHN0ZXAoY29udGV4dCk7XG59O1xuY29uc3QgaXNXaW5kb3cgPSAob2JqKSA9PiBvYmoud2luZG93ID09PSBvYmo7XG5jb25zdCBjcmVhdGVTY3JvbGwgPSAoc2Nyb2xsTmFtZSkgPT4gKHRhcmdldCwgc2Nyb2xsT3B0aW9ucywgY29uZmlnKSA9PiB7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNjcm9sbFR5cGVdID0gaXNXaW5kb3codGFyZ2V0KVxuICAgICAgICA/IFtzY3JvbGxpbmdFbGVtZW50KHRhcmdldC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLCBcIldpbmRvd1wiXVxuICAgICAgICA6IFt0YXJnZXQsIFwiRWxlbWVudFwiXTtcbiAgICBjb25zdCBvcHRpb25zID0gc2Nyb2xsT3B0aW9ucyAhPT0gbnVsbCAmJiBzY3JvbGxPcHRpb25zICE9PSB2b2lkIDAgPyBzY3JvbGxPcHRpb25zIDoge307XG4gICAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZhaWxlZEV4ZWN1dGUoc2Nyb2xsTmFtZSwgc2Nyb2xsVHlwZSkpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrQmVoYXZpb3Iob3B0aW9ucy5iZWhhdmlvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZShzY3JvbGxOYW1lLCBzY3JvbGxUeXBlLCBvcHRpb25zLmJlaGF2aW9yKSk7XG4gICAgfVxuICAgIGlmIChzY3JvbGxOYW1lID09PSBcInNjcm9sbEJ5XCIpIHtcbiAgICAgICAgb3B0aW9ucy5sZWZ0ID0gbm9uRmluaXRlKG9wdGlvbnMubGVmdCkgKyBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIG9wdGlvbnMudG9wID0gbm9uRmluaXRlKG9wdGlvbnMudG9wKSArIGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBzY3JvbGxXaXRoT3B0aW9ucyhlbGVtZW50LCBvcHRpb25zLCBjb25maWcpO1xufTtcbmV4cG9ydCBjb25zdCBzY3JvbGwgPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlU2Nyb2xsKFwic2Nyb2xsXCIpO1xuZXhwb3J0IGNvbnN0IHNjcm9sbFRvID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVNjcm9sbChcInNjcm9sbFRvXCIpO1xuZXhwb3J0IGNvbnN0IHNjcm9sbEJ5ID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVNjcm9sbChcInNjcm9sbEJ5XCIpO1xuZXhwb3J0IGNvbnN0IGVsZW1lbnRTY3JvbGwgPSBzY3JvbGw7XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbFRvID0gc2Nyb2xsVG87XG5leHBvcnQgY29uc3QgZWxlbWVudFNjcm9sbEJ5ID0gc2Nyb2xsQnk7XG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsID0gc2Nyb2xsO1xuZXhwb3J0IGNvbnN0IHdpbmRvd1Njcm9sbFRvID0gc2Nyb2xsVG87XG5leHBvcnQgY29uc3Qgd2luZG93U2Nyb2xsQnkgPSBzY3JvbGxCeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5pbXBvcnQgeyBjaGVja0JlaGF2aW9yLCBmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZSwgc2Nyb2xsaW5nRWxlbWVudCB9IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgZWxlbWVudFNjcm9sbCB9IGZyb20gXCIuL3Njcm9sbC5qc1wiO1xuLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy13cml0aW5nLW1vZGVzLTQvI2Jsb2NrLWZsb3dcbmNvbnN0IG5vcm1hbGl6ZVdyaXRpbmdNb2RlID0gKHdyaXRpbmdNb2RlKSA9PiB7XG4gICAgc3dpdGNoICh3cml0aW5nTW9kZSkge1xuICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbC10YlwiOlxuICAgICAgICBjYXNlIFwibHJcIjpcbiAgICAgICAgY2FzZSBcImxyLXRiXCI6XG4gICAgICAgIGNhc2UgXCJybFwiOlxuICAgICAgICBjYXNlIFwicmwtdGJcIjpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIEhvcml6b250YWxUYiAqLztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsLXJsXCI6XG4gICAgICAgIGNhc2UgXCJ0YlwiOlxuICAgICAgICBjYXNlIFwidGItcmxcIjpcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFZlcnRpY2FsUmwgKi87XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbC1sclwiOlxuICAgICAgICBjYXNlIFwidGItbHJcIjpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFZlcnRpY2FsTHIgKi87XG4gICAgICAgIGNhc2UgXCJzaWRld2F5cy1ybFwiOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogU2lkZXdheXNSbCAqLztcbiAgICAgICAgY2FzZSBcInNpZGV3YXlzLWxyXCI6XG4gICAgICAgICAgICByZXR1cm4gNCAvKiBTaWRld2F5c0xyICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBIb3Jpem9udGFsVGIgKi87XG59O1xuY29uc3QgY2FsY1BoeXNpY2FsQXhpcyA9ICh3cml0aW5nTW9kZSwgaXNMVFIsIGhQb3MsIHZQb3MpID0+IHtcbiAgICAvKiogIDBie3ZlcnRpY2FsfXtob3Jpem9udGFsfSAgMDogbm9ybWFsLCAxOiByZXZlcnNlICovXG4gICAgbGV0IGxheW91dCA9IDBiMDA7XG4gICAgLyoqXG4gICAgICogV3JpdGluZ01vZGUuVmVydGljYWxMcjog4oaT4oaSXG4gICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAqIHwgMiB8IDUgfCAgIHxcbiAgICAgKiB8IDMgfCAgIHwgICB8XG4gICAgICpcbiAgICAgKiBSVEw6IOKGkeKGklxuICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgKiB8IDIgfCA1IHwgICB8XG4gICAgICogfCAxIHwgNCB8ICAgfFxuICAgICAqL1xuICAgIGlmICghaXNMVFIpIHtcbiAgICAgICAgbGF5b3V0IF49IDIgLyogUmV2ZXJzZVZlcnRpY2FsICovO1xuICAgIH1cbiAgICBzd2l0Y2ggKHdyaXRpbmdNb2RlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDihpPihpJcbiAgICAgICAgICogfCAxIHwgMiB8IDMgfFxuICAgICAgICAgKiB8IDQgfCA1IHwgICB8XG4gICAgICAgICAqIHwgICB8ICAgfCAgIHxcbiAgICAgICAgICpcbiAgICAgICAgICogUlRMOiDihpPihpBcbiAgICAgICAgICogfCAzIHwgMiB8IDEgfFxuICAgICAgICAgKiB8ICAgfCA1IHwgNCB8XG4gICAgICAgICAqIHwgICB8ICAgfCAgIHxcbiAgICAgICAgICovXG4gICAgICAgIGNhc2UgMCAvKiBIb3Jpem9udGFsVGIgKi86XG4gICAgICAgICAgICAvLyBzd2FwIGhvcml6b250YWwgYW5kIHZlcnRpY2FsXG4gICAgICAgICAgICBsYXlvdXQgPSAobGF5b3V0ID4+IDEpIHwgKChsYXlvdXQgJiAxKSA8PCAxKTtcbiAgICAgICAgICAgIFtoUG9zLCB2UG9zXSA9IFt2UG9zLCBoUG9zXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKipcbiAgICAgICAgICog4oaT4oaQXG4gICAgICAgICAqIHwgICB8IDQgfCAxIHxcbiAgICAgICAgICogfCAgIHwgNSB8IDIgfFxuICAgICAgICAgKiB8ICAgfCAgIHwgMyB8XG4gICAgICAgICAqXG4gICAgICAgICAqIFJUTDog4oaR4oaQXG4gICAgICAgICAqIHwgICB8ICAgfCAzIHxcbiAgICAgICAgICogfCAgIHwgNSB8IDIgfFxuICAgICAgICAgKiB8ICAgfCA0IHwgMSB8XG4gICAgICAgICAqL1xuICAgICAgICBjYXNlIDEgLyogVmVydGljYWxSbCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIFNpZGV3YXlzUmwgKi86XG4gICAgICAgICAgICAvLyAgcmV2ZXJzZSBob3Jpem9udGFsXG4gICAgICAgICAgICBsYXlvdXQgXj0gMSAvKiBSZXZlcnNlSG9yaXpvbnRhbCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKipcbiAgICAgICAgICog4oaR4oaSXG4gICAgICAgICAqIHwgMyB8ICAgfCAgIHxcbiAgICAgICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAgICAgKiB8IDEgfCA0IHwgICB8XG4gICAgICAgICAqXG4gICAgICAgICAqIFJUTDog4oaT4oaSXG4gICAgICAgICAqIHwgMSB8IDQgfCAgIHxcbiAgICAgICAgICogfCAyIHwgNSB8ICAgfFxuICAgICAgICAgKiB8IDMgfCAgIHwgICB8XG4gICAgICAgICAqL1xuICAgICAgICBjYXNlIDQgLyogU2lkZXdheXNMciAqLzpcbiAgICAgICAgICAgIC8vIHJldmVyc2UgdmVydGljYWxcbiAgICAgICAgICAgIGxheW91dCBePSAyIC8qIFJldmVyc2VWZXJ0aWNhbCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gW2xheW91dCwgaFBvcywgdlBvc107XG59O1xuY29uc3QgaXNYUmV2ZXJzZWQgPSAoY29tcHV0ZWRTdHlsZSkgPT4ge1xuICAgIGNvbnN0IGxheW91dCA9IGNhbGNQaHlzaWNhbEF4aXMobm9ybWFsaXplV3JpdGluZ01vZGUoY29tcHV0ZWRTdHlsZS53cml0aW5nTW9kZSksIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uICE9PSBcInJ0bFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZClbMF07XG4gICAgcmV0dXJuIChsYXlvdXQgJiAxKSA9PT0gMTtcbn07XG4vLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp0aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2RvbS9lbGVtZW50LmNjO2w9MTA5Ny0xMTg5O2RyYz02YTc1MzNkNGExZTlmMjM3MjIyM2E5ZDkxMmE5ZTUzYTZmYTM1YWUwXG5jb25zdCB0b1BoeXNpY2FsQWxpZ25tZW50ID0gKG9wdGlvbnMsIHdyaXRpbmdNb2RlLCBpc0xUUikgPT4ge1xuICAgIGNvbnN0IFtsYXlvdXQsIGhQb3MsIHZQb3NdID0gY2FsY1BoeXNpY2FsQXhpcyh3cml0aW5nTW9kZSwgaXNMVFIsIG9wdGlvbnMuYmxvY2sgfHwgXCJzdGFydFwiLCBvcHRpb25zLmlubGluZSB8fCBcIm5lYXJlc3RcIik7XG4gICAgcmV0dXJuIFtoUG9zLCB2UG9zXS5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2VudGVyQWx3YXlzICovO1xuICAgICAgICAgICAgY2FzZSBcIm5lYXJlc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBUb0VkZ2VJZk5lZWRlZCAqLztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlID0gKGxheW91dCA+PiBpbmRleCkgJiAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IFwic3RhcnRcIikgPT09ICFyZXZlcnNlID8gMiAvKiBMZWZ0T3JUb3AgKi8gOiAzIC8qIFJpZ2h0T3JCb3R0b20gKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vLyBjb2RlIGZyb20gc3RpcHNhbi9jb21wdXRlLXNjcm9sbC1pbnRvLXZpZXdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGlwc2FuL2NvbXB1dGUtc2Nyb2xsLWludG8tdmlldy9ibG9iLzUzOTZjNmI3OGFmNWQwYmJjZTExYTdjNGU5M2NjMzE0NjU0NmZjZDMvc3JjL2luZGV4LnRzXG4vKipcbiAqIEZpbmQgb3V0IHdoaWNoIGVkZ2UgdG8gYWxpZ24gYWdhaW5zdCB3aGVuIGxvZ2ljYWwgc2Nyb2xsIHBvc2l0aW9uIGlzIFwibmVhcmVzdFwiXG4gKiBJbnRlcmVzdGluZyBmYWN0OiBcIm5lYXJlc3RcIiB3b3JrcyBzaW1pbGFyaWx5IHRvIFwiaWYtbmVlZGVkXCIsIGlmIHRoZSBlbGVtZW50IGlzIGZ1bGx5IHZpc2libGUgaXQgd2lsbCBub3Qgc2Nyb2xsIGl0XG4gKlxuICogTGVnZW5kczpcbiAqIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilI8g4pSBIOKUgSDilIEg4pSTXG4gKiDilIIgdGFyZ2V0IOKUgiAgIGZyYW1lXG4gKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilJgg4pSXIOKUgSDilIEg4pSBIOKUm1xuICovXG5jb25zdCBtYXBOZWFyZXN0ID0gKGFsaWduLCBzY3JvbGxpbmdFZGdlU3RhcnQsIHNjcm9sbGluZ0VkZ2VFbmQsIHNjcm9sbGluZ1NpemUsIGVsZW1lbnRFZGdlU3RhcnQsIGVsZW1lbnRFZGdlRW5kLCBlbGVtZW50U2l6ZSkgPT4ge1xuICAgIGlmIChhbGlnbiAhPT0gMCAvKiBUb0VkZ2VJZk5lZWRlZCAqLykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGFuZCBlbGVtZW50IGVkZ2UgQiBhcmUgYm90aCBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBzY3JvbGxpbmcgYm94IGVkZ2UgQlxuICAgICAqXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgIOKUj+KUgeKUguKUgeKUgeKUguKUgeKUk1xuICAgICAqICAgICAgICAgIOKUgiAg4pSCXG4gICAgICogICAgICAgIOKUgyDilIIgIOKUgiDilIMgICAgICAgIGRvIG5vdGhpbmdcbiAgICAgKiAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJtcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKlxuICAgICAqICBJZiBlbGVtZW50IGVkZ2UgQyBhbmQgZWxlbWVudCBlZGdlIEQgYXJlIGJvdGggb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgc2Nyb2xsaW5nIGJveCBlZGdlIERcbiAgICAgKlxuICAgICAqICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgKiAgIOKUguKUgyAgICAgICAgIOKUg+KUgiAgICAgICAgZG8gbm90aGluZ1xuICAgICAqICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICogICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKi9cbiAgICBpZiAoKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kKSB8fFxuICAgICAgICAoZWxlbWVudEVkZ2VTdGFydCA+IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50RWRnZUVuZCA8IHNjcm9sbGluZ0VkZ2VFbmQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQSBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBBIGFuZCBlbGVtZW50IGhlaWdodCBpcyBsZXNzIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgKlxuICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilI/ilIHilILilIHilIHilILilIHilJMgICAgICAgICDilI/ilIHilIzilIHilIHilJDilIHilJNcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJggICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgZnJvbSAg4pSDICAgICAg4pSDICAgICB0byAg4pSDIOKUlOKUgOKUgOKUmCDilINcbiAgICAgKlxuICAgICAqICAgICAgICDilJfilIEg4pSB4pSBIOKUgeKUmyAgICAgICAgIOKUl+KUgSDilIHilIEg4pSB4pSbXG4gICAgICpcbiAgICAgKiBJZiBlbGVtZW50IGVkZ2UgQiBpcyBvdXRzaWRlIHNjcm9sbGluZyBib3ggZWRnZSBCIGFuZCBlbGVtZW50IGhlaWdodCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCBoZWlnaHRcbiAgICAgKlxuICAgICAqICAgICAgICDilI/ilIEg4pSB4pSBIOKUgeKUkyAgICAgICAgIOKUj+KUgeKUjOKUgeKUgeKUkOKUgeKUk1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgZnJvbSAg4pSDIOKUjOKUgOKUgOKUkCDilIMgICAgIHRvICDilIMg4pSCICDilIIg4pSDXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbICAgICAgICAg4pSX4pSB4pSC4pSB4pSB4pSC4pSB4pSbXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSU4pSA4pSA4pSYXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBDIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEMgYW5kIGVsZW1lbnQgd2lkdGggaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICDilIzilIDilIDilIDilJAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxuICAgICAqICDilIIg4pSDIOKUgiAgICAgICDilIMgICAgICAgICDilIMgICDilIIgICAgIOKUg1xuICAgICAqICDilJTilIDilIDilIDilJggICAgICAgICAgICAgICAgIOKUlOKUgOKUgOKUgOKUmFxuICAgICAqICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBEIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEQgYW5kIGVsZW1lbnQgd2lkdGggaXMgZ3JlYXRlciB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJMgICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUk1xuICAgICAqICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgKiAgICDilIMgICDilIIgICAgIOKUgyAgICAg4pSCICAg4pSDICAgICAgICAg4pSDIOKUglxuICAgICAqICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiAgICAgKiAgICDilJcg4pSBIOKUgSDilIEg4pSBIOKUmyAgICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbXG4gICAgICovXG4gICAgaWYgKChlbGVtZW50RWRnZVN0YXJ0IDw9IHNjcm9sbGluZ0VkZ2VTdGFydCAmJiBlbGVtZW50U2l6ZSA8PSBzY3JvbGxpbmdTaXplKSB8fFxuICAgICAgICAoZWxlbWVudEVkZ2VFbmQgPj0gc2Nyb2xsaW5nRWRnZUVuZCAmJiBlbGVtZW50U2l6ZSA+PSBzY3JvbGxpbmdTaXplKSkge1xuICAgICAgICByZXR1cm4gMiAvKiBMZWZ0T3JUb3AgKi87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBCIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEIgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGxlc3MgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgIOKUj+KUgSDilIHilIEg4pSB4pSTICAgICAgICAg4pSP4pSBIOKUgeKUgSDilIHilJNcbiAgICAgKlxuICAgICAqICBmcm9tICDilIMgICAgICDilIMgICAgIHRvICDilIMg4pSM4pSA4pSA4pSQIOKUg1xuICAgICAqICAgICAgICAgIOKUjOKUgOKUgOKUkCAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIHilILilIHilIHilILilIHilJsgICAgICAgICDilJfilIHilJTilIHilIHilJjilIHilJtcbiAgICAgKiAgICAgICAgICDilJTilIDilIDilJhcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBBIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEEgYW5kIGVsZW1lbnQgaGVpZ2h0IGlzIGdyZWF0ZXIgdGhhbiBzY3JvbGxpbmcgYm94IGhlaWdodFxuICAgICAqXG4gICAgICogICAgICAgICAg4pSM4pSA4pSA4pSQXG4gICAgICogICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICDilIzilIDilIDilJBcbiAgICAgKiAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTICAgICAgICAg4pSP4pSB4pSC4pSB4pSB4pSC4pSB4pSTXG4gICAgICogICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAg4pSCICDilIJcbiAgICAgKiAgZnJvbSAg4pSDIOKUlOKUgOKUgOKUmCDilIMgICAgIHRvICDilIMg4pSCICDilIIg4pSDXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUglxuICAgICAqICAgICAgICDilJfilIEg4pSB4pSBIOKUgeKUmyAgICAgICAgIOKUl+KUgeKUlOKUgeKUgeKUmOKUgeKUm1xuICAgICAqXG4gICAgICogSWYgZWxlbWVudCBlZGdlIEMgaXMgb3V0c2lkZSBzY3JvbGxpbmcgYm94IGVkZ2UgQyBhbmQgZWxlbWVudCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gc2Nyb2xsaW5nIGJveCB3aWR0aFxuICAgICAqXG4gICAgICogICAgICAgICAgIGZyb20gICAgICAgICAgICAgICAgIHRvXG4gICAgICogICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTICAgICAgICAg4pSPIOKUgSDilIEg4pSBIOKUgSDilJNcbiAgICAgKiAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgKiAg4pSCICAgICDilIMgICAgIOKUgiAgIOKUgyAgICAgICDilIIg4pSDICAgICAgICAg4pSDXG4gICAgICogIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4gICAgICogICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKlxuICAgICAqIElmIGVsZW1lbnQgZWRnZSBEIGlzIG91dHNpZGUgc2Nyb2xsaW5nIGJveCBlZGdlIEQgYW5kIGVsZW1lbnQgd2lkdGggaXMgbGVzcyB0aGFuIHNjcm9sbGluZyBib3ggd2lkdGhcbiAgICAgKlxuICAgICAqICAgICAgICAgICBmcm9tICAgICAgICAgICAgICAgICB0b1xuICAgICAqICAgICAgICDilI8g4pSBIOKUgSDilIEg4pSBIOKUkyAgICAgICAgIOKUjyDilIEg4pSBIOKUgSDilIEg4pSTXG4gICAgICogICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxuICAgICAqICAgICAgICDilIMgICAgICAg4pSCIOKUgyDilIIgICAgICAg4pSDICAgICDilIIgICDilINcbiAgICAgKiAgICAgICAgICAgICAgICDilJTilIDilIDilIDilJggICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXG4gICAgICogICAgICAgIOKUlyDilIEg4pSBIOKUgSDilIEg4pSbICAgICAgICAg4pSXIOKUgSDilIEg4pSBIOKUgSDilJtcbiAgICAgKlxuICAgICAqL1xuICAgIGlmICgoZWxlbWVudEVkZ2VFbmQgPiBzY3JvbGxpbmdFZGdlRW5kICYmIGVsZW1lbnRTaXplIDwgc2Nyb2xsaW5nU2l6ZSkgfHxcbiAgICAgICAgKGVsZW1lbnRFZGdlU3RhcnQgPCBzY3JvbGxpbmdFZGdlU3RhcnQgJiYgZWxlbWVudFNpemUgPiBzY3JvbGxpbmdTaXplKSkge1xuICAgICAgICByZXR1cm4gMyAvKiBSaWdodE9yQm90dG9tICovO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBjYW5PdmVyZmxvdyA9IChvdmVyZmxvdykgPT4ge1xuICAgIHJldHVybiBvdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCIgJiYgb3ZlcmZsb3cgIT09IFwiY2xpcFwiO1xufTtcbmNvbnN0IGdldEZyYW1lRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoKF9hID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWVFbGVtZW50KSB8fCBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmNvbnN0IGlzU2Nyb2xsYWJsZSA9IChlbGVtZW50LCBjb21wdXRlZFN0eWxlKSA9PiB7XG4gICAgaWYgKGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgZWxlbWVudC5jbGllbnRXaWR0aCA8IGVsZW1lbnQuc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIChjYW5PdmVyZmxvdyhjb21wdXRlZFN0eWxlLm92ZXJmbG93WSkgfHxcbiAgICAgICAgICAgIGNhbk92ZXJmbG93KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSB8fFxuICAgICAgICAgICAgZWxlbWVudCA9PT0gc2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBwYXJlbnRFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBwTm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBjb25zdCBwRWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAocEVsZW1lbnQgPT09IG51bGwgJiYgcE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHBOb2RlLm5vZGVUeXBlID09PSAvKiogTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICovIDExKSB7XG4gICAgICAgICAgICByZXR1cm4gcE5vZGUuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocE5vZGUubm9kZVR5cGUgPT09IC8qKiBOb2RlLkRPQ1VNRU5UX05PREUgKi8gOSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZyYW1lRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcEVsZW1lbnQ7XG59O1xuY29uc3QgY2xhbXAgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuY29uc3QgZ2V0U3VwcG9ydGVkU2Nyb2xsTWFyZ2luUHJvcGVydHkgPSAob3duZXJEb2N1bWVudCkgPT4ge1xuICAgIC8vIFdlYmtpdCB1c2VzIFwic2Nyb2xsLXNuYXAtbWFyZ2luXCIgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4OTI2NS5cbiAgICByZXR1cm4gW1wic2Nyb2xsLW1hcmdpblwiLCBcInNjcm9sbC1zbmFwLW1hcmdpblwiXS5maWx0ZXIoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eSBpbiBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSlbMF07XG59O1xuY29uc3QgZ2V0RWxlbWVudFNjcm9sbFNuYXBBcmVhID0gKGVsZW1lbnQsIGVsZW1lbnRSZWN0LCBjb21wdXRlZFN0eWxlKSA9PiB7XG4gICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IGVsZW1lbnRSZWN0O1xuICAgIGNvbnN0IHNjcm9sbFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkU2Nyb2xsTWFyZ2luUHJvcGVydHkoZWxlbWVudC5vd25lckRvY3VtZW50KTtcbiAgICBpZiAoIXNjcm9sbFByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XTtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsTWFyZ2luVmFsdWUgPSAoZWRnZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShgJHtzY3JvbGxQcm9wZXJ0eX0tJHtlZGdlfWApO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xuICAgIH07XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdG9wIC0gc2Nyb2xsTWFyZ2luVmFsdWUoXCJ0b3BcIiksXG4gICAgICAgIHJpZ2h0ICsgc2Nyb2xsTWFyZ2luVmFsdWUoXCJyaWdodFwiKSxcbiAgICAgICAgYm90dG9tICsgc2Nyb2xsTWFyZ2luVmFsdWUoXCJib3R0b21cIiksXG4gICAgICAgIGxlZnQgLSBzY3JvbGxNYXJnaW5WYWx1ZShcImxlZnRcIiksXG4gICAgXTtcbn07XG5jb25zdCBjYWxjQWxpZ25FZGdlID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiB7XG4gICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIDEgLyogQ2VudGVyQWx3YXlzICovOlxuICAgICAgICAgICAgcmV0dXJuIChzdGFydCArIGVuZCkgLyAyO1xuICAgICAgICBjYXNlIDMgLyogUmlnaHRPckJvdHRvbSAqLzpcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGNhc2UgMiAvKiBMZWZ0T3JUb3AgKi86XG4gICAgICAgIGNhc2UgMCAvKiBUb0VkZ2VJZk5lZWRlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG59O1xuY29uc3QgZ2V0RnJhbWVWaWV3cG9ydCA9IChmcmFtZSwgZnJhbWVSZWN0KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSAoX2EgPSBmcmFtZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmlzdWFsVmlld3BvcnQ7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZnJhbWUgPT09IHNjcm9sbGluZ0VsZW1lbnQoZnJhbWUpXG4gICAgICAgID8gWzAsIDAsIChfYiA9IHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8IHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxWaWV3cG9ydC53aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnJhbWUuY2xpZW50V2lkdGgsIChfYyA9IHZpc3VhbFZpZXdwb3J0ID09PSBudWxsIHx8IHZpc3VhbFZpZXdwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxWaWV3cG9ydC5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZyYW1lLmNsaWVudEhlaWdodF1cbiAgICAgICAgOiBbZnJhbWVSZWN0LmxlZnQsIGZyYW1lUmVjdC50b3AsIGZyYW1lLmNsaWVudFdpZHRoLCBmcmFtZS5jbGllbnRIZWlnaHRdO1xuICAgIGNvbnN0IGxlZnQgPSB4ICsgZnJhbWUuY2xpZW50TGVmdDtcbiAgICBjb25zdCB0b3AgPSB5ICsgZnJhbWUuY2xpZW50VG9wO1xuICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF07XG59O1xuY29uc3QgY29tcHV0ZVNjcm9sbEludG9WaWV3ID0gKGVsZW1lbnQsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBDb2xsZWN0IGFsbCB0aGUgc2Nyb2xsaW5nIGJveGVzLCBhcyBkZWZpbmVkIGluIHRoZSBzcGVjOiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20tdmlldy8jc2Nyb2xsaW5nLWJveFxuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICBsZXQgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBsZXQgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGlmICghb3duZXJXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBjb25zdCBpc0xUUiA9IGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uICE9PSBcInJ0bFwiO1xuICAgIGNvbnN0IHdyaXRpbmdNb2RlID0gbm9ybWFsaXplV3JpdGluZ01vZGUoY29tcHV0ZWRTdHlsZS53cml0aW5nTW9kZSB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItd2Via2l0LXdyaXRpbmctbW9kZVwiKSB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItbXMtd3JpdGluZy1tb2RlXCIpKTtcbiAgICBjb25zdCBbYWxpZ25ILCBhbGlnblZdID0gdG9QaHlzaWNhbEFsaWdubWVudChvcHRpb25zLCB3cml0aW5nTW9kZSwgaXNMVFIpO1xuICAgIGxldCBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XSA9IGdldEVsZW1lbnRTY3JvbGxTbmFwQXJlYShlbGVtZW50LCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBjb21wdXRlZFN0eWxlKTtcbiAgICBmb3IgKGxldCBmcmFtZSA9IHBhcmVudEVsZW1lbnQoZWxlbWVudCk7IGZyYW1lICE9PSBudWxsOyBmcmFtZSA9IHBhcmVudEVsZW1lbnQoZnJhbWUpKSB7XG4gICAgICAgIGlmIChvd25lckRvY3VtZW50ICE9PSBmcmFtZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50ID0gZnJhbWUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIGlmICghb3duZXJXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbGVmdDogZFgsIHRvcDogZFkgfSA9IGZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdG9wICs9IGRZO1xuICAgICAgICAgICAgcmlnaHQgKz0gZFg7XG4gICAgICAgICAgICBib3R0b20gKz0gZFk7XG4gICAgICAgICAgICBsZWZ0ICs9IGRYO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGZyYW1lKTtcbiAgICAgICAgaWYgKGZyYW1lU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Njcm9sbGFibGUoZnJhbWUsIGZyYW1lU3R5bGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZVJlY3QgPSBmcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgW2ZyYW1lVG9wLCBmcmFtZVJpZ2h0LCBmcmFtZUJvdHRvbSwgZnJhbWVMZWZ0XSA9IGdldEZyYW1lVmlld3BvcnQoZnJhbWUsIGZyYW1lUmVjdCk7XG4gICAgICAgIGNvbnN0IGVBbGlnbkggPSBtYXBOZWFyZXN0KGFsaWduSCwgZnJhbWVMZWZ0LCBmcmFtZVJpZ2h0LCBmcmFtZS5jbGllbnRXaWR0aCwgbGVmdCwgcmlnaHQsIHJpZ2h0IC0gbGVmdCk7XG4gICAgICAgIGNvbnN0IGVBbGlnblYgPSBtYXBOZWFyZXN0KGFsaWduViwgZnJhbWVUb3AsIGZyYW1lQm90dG9tLCBmcmFtZS5jbGllbnRIZWlnaHQsIHRvcCwgYm90dG9tLCBib3R0b20gLSB0b3ApO1xuICAgICAgICBjb25zdCBkaWZmWCA9IGVBbGlnbkggPT09IG51bGwgPyAwIDogY2FsY0FsaWduRWRnZShlQWxpZ25ILCBsZWZ0LCByaWdodCkgLSBjYWxjQWxpZ25FZGdlKGVBbGlnbkgsIGZyYW1lTGVmdCwgZnJhbWVSaWdodCk7XG4gICAgICAgIGNvbnN0IGRpZmZZID0gZUFsaWduViA9PT0gbnVsbCA/IDAgOiBjYWxjQWxpZ25FZGdlKGVBbGlnblYsIHRvcCwgYm90dG9tKSAtIGNhbGNBbGlnbkVkZ2UoZUFsaWduViwgZnJhbWVUb3AsIGZyYW1lQm90dG9tKTtcbiAgICAgICAgY29uc3QgbW92ZVggPSBpc1hSZXZlcnNlZChmcmFtZVN0eWxlKVxuICAgICAgICAgICAgPyBjbGFtcChkaWZmWCwgLWZyYW1lLnNjcm9sbFdpZHRoICsgZnJhbWUuY2xpZW50V2lkdGggLSBmcmFtZS5zY3JvbGxMZWZ0LCAtZnJhbWUuc2Nyb2xsTGVmdClcbiAgICAgICAgICAgIDogY2xhbXAoZGlmZlgsIC1mcmFtZS5zY3JvbGxMZWZ0LCBmcmFtZS5zY3JvbGxXaWR0aCAtIGZyYW1lLmNsaWVudFdpZHRoIC0gZnJhbWUuc2Nyb2xsTGVmdCk7XG4gICAgICAgIGNvbnN0IG1vdmVZID0gY2xhbXAoZGlmZlksIC1mcmFtZS5zY3JvbGxUb3AsIGZyYW1lLnNjcm9sbEhlaWdodCAtIGZyYW1lLmNsaWVudEhlaWdodCAtIGZyYW1lLnNjcm9sbFRvcCk7XG4gICAgICAgIGFjdGlvbnMucHVzaChbXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIHsgbGVmdDogZnJhbWUuc2Nyb2xsTGVmdCArIG1vdmVYLCB0b3A6IGZyYW1lLnNjcm9sbFRvcCArIG1vdmVZLCBiZWhhdmlvcjogb3B0aW9ucy5iZWhhdmlvciB9LFxuICAgICAgICBdKTtcbiAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wIC0gbW92ZVksIGZyYW1lVG9wKTtcbiAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCAtIG1vdmVYLCBmcmFtZVJpZ2h0KTtcbiAgICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tIC0gbW92ZVksIGZyYW1lQm90dG9tKTtcbiAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQgLSBtb3ZlWCwgZnJhbWVMZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbnM7XG59O1xuZXhwb3J0IGNvbnN0IHNjcm9sbEludG9WaWV3ID0gKGVsZW1lbnQsIHNjcm9sbEludG9WaWV3T3B0aW9ucywgY29uZmlnKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIWNoZWNrQmVoYXZpb3Iob3B0aW9ucy5iZWhhdmlvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmYWlsZWRFeGVjdXRlSW52YWxpZEVudW1WYWx1ZShcInNjcm9sbEludG9WaWV3XCIsIFwiRWxlbWVudFwiLCBvcHRpb25zLmJlaGF2aW9yKSk7XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbnMgPSBjb21wdXRlU2Nyb2xsSW50b1ZpZXcoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgYWN0aW9ucy5mb3JFYWNoKChbZnJhbWUsIHNjcm9sbFRvT3B0aW9uc10pID0+IHtcbiAgICAgICAgZWxlbWVudFNjcm9sbChmcmFtZSwgc2Nyb2xsVG9PcHRpb25zLCBjb25maWcpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBlbGVtZW50U2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbEludG9WaWV3LmpzLm1hcCIsImltcG9ydCB7IGVsZW1lbnRTY3JvbGxJbnRvVmlldyB9IGZyb20gXCJzZWFtbGVzcy1zY3JvbGwtcG9seWZpbGxcIjtcclxuXHJcbmNvbnN0IHNtb3RoU2Nyb2xsID0gKCkgPT4ge1xyXG4gICBjb25zdCBnZXROYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWVudS1saXN0Jyk7XHJcbiAgIGNvbnN0IG1haW5TY3JvbGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbl9fc2Nyb2xsJyk7XHJcblxyXG4gICBjb25zdCBnb1NlY3Rpb24gPSB0YXJnZXQgPT4ge1xyXG4gICAgICBjb25zdCBnZXRJZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKS5zbGljZSgxKTtcclxuICAgICAgY29uc3QgZ2V0U2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdldElkKTtcclxuICAgICAgaWYgKGdldFNlY3Rpb24pIHtcclxuICAgICAgICAgZWxlbWVudFNjcm9sbEludG9WaWV3KGdldFNlY3Rpb24sIHsgYmVoYXZpb3I6IFwic21vb3RoXCIsIGJsb2NrOiBcImNlbnRlclwiLCBpbmxpbmU6IFwiY2VudGVyXCIgfSk7XHJcbiAgICAgIH1cclxuICAgfTtcclxuICAgY29uc3QgYWN0aXZlTGluayA9IChlKSA9PiB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLm1lbnUtbGlzdF9faXRlbScpKSB7XHJcbiAgICAgICAgIGNvbnN0IGdldFBhcmVudCA9IHRhcmdldC5jbG9zZXN0KCcubWVudS1saXN0X19pdGVtJyk7XHJcbiAgICAgICAgIGNvbnN0IGdldExpbmsgPSBnZXRQYXJlbnQucXVlcnlTZWxlY3RvcignLm1lbnUtbGlzdF9fbGluaycpO1xyXG4gICAgICAgICBnb1NlY3Rpb24oZ2V0TGluayk7XHJcbiAgICAgIH1cclxuICAgfTtcclxuXHJcbiAgIGdldE5hdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFjdGl2ZUxpbmspO1xyXG4gICBtYWluU2Nyb2xsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZ29TZWN0aW9uKG1haW5TY3JvbGwpO1xyXG4gICB9KTtcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgc21vdGhTY3JvbGw7IiwiY29uc3QgdGFicyA9ICgpID0+IHtcclxuICAgY29uc3QgZGVzaWduTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXNpZ24tbGlzdCcpO1xyXG4gICBjb25zdCBnZXRUYWJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlc2lnbi1saXN0X19pdGVtJyk7XHJcbiAgIGNvbnN0IHRhYnNEZXNjcmlwdGlvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZXNpZ25fX2Rlc2NyJyk7XHJcbiAgIGNvbnN0IGRlc2lnbkJsb2NrID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlc2lnbi1ibG9jayA+IGltZycpO1xyXG4gICBjb25zdCBkZXNpZ25JbWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVzaWduLWltYWdlcycpO1xyXG4gICBjb25zdCBkZXNpZ25UaXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kZXNpZ25fX3RpdGxlJyk7XHJcblxyXG4gICBsZXQgYWN0aXZlVGFyZ2V0ID0gJyc7XHJcblxyXG4gICBjb25zdCBhY3RpdmVUYWIgPSBlID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgY29uc3QgYWN0aXZlQmxvY2sgPSBzZWxlY3RvciA9PiB7XHJcbiAgICAgICAgIHNlbGVjdG9yLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGl0ZW0uZGF0YXNldC50YWJzRmllbGQgPT09IGFjdGl2ZVRhcmdldCA/XHJcbiAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJykgOlxyXG4gICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZGVzaWduLWxpc3RfX2l0ZW0nKSAmJiAhdGFyZ2V0LmNsb3Nlc3QoJy5kZXNpZ24tbGlzdF9faXRlbV9hY3RpdmUnKSkge1xyXG4gICAgICAgICBnZXRUYWJzLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2Rlc2lnbi1saXN0X19pdGVtX2FjdGl2ZScpKTtcclxuICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2Rlc2lnbi1saXN0X19pdGVtX2FjdGl2ZScpO1xyXG4gICAgICAgICBhY3RpdmVUYXJnZXQgPSB0YXJnZXQuZGF0YXNldC50YWJzSGFuZGxlcjtcclxuICAgICAgICAgZGVzaWduVGl0bGUuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBbLi4uZ2V0VGFic10uaW5kZXhPZih0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0aXRsZVwiKS50ZXh0Q29udGVudCA9IGl0ZW0udGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICBhY3RpdmVCbG9jayh0YWJzRGVzY3JpcHRpb24pO1xyXG4gICAgICAgICBhY3RpdmVCbG9jayhkZXNpZ25JbWcpO1xyXG4gICAgICAgICBhY3RpdmVCbG9jayhkZXNpZ25CbG9jayk7XHJcbiAgICAgIH1cclxuICAgfTtcclxuXHJcbiAgIGRlc2lnbkxpc3QuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhY3RpdmVUYWIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdGFiczsiLCJpbXBvcnQgY2hlY2tGb3JtIGZyb20gXCIuL2NoZWNrRm9ybS5qc1wiO1xyXG5cclxuY29uc3QgbWFpbkZvcm0gPSAoKSA9PiB7XHJcbiAgIGNvbnN0IGZvcm1CdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybV9fYnV0dG9uJyk7XHJcbiAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZm9ybS10ZXN0LWRyaXZlJyk7XHJcbiAgIGNvbnN0IGdldElucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb3JtLXRlc3QtZHJpdmUgPiBpbnB1dCcpO1xyXG5cclxuICAgY29uc3Qgc2VuZEZvcm0gPSBhc3luYyBlID0+IHtcclxuICAgICAgYXdhaXQgY29uc29sZS5sb2coY2hlY2tGb3JtKGUsIGZvcm0sIFsuLi5nZXRJbnB1dHNdKSk7XHJcbiAgIH07XHJcbiAgIGZvcm1CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZW5kRm9ybSk7XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IG1haW5Gb3JtOyIsImltcG9ydCBhY2NvcmRlb24gZnJvbSBcIi4vbW9kdWxlcy9hY2NvcmRlb25cIjtcclxuaW1wb3J0IGNvdW50VGltZXIgZnJvbSBcIi4vbW9kdWxlcy9jb3VudFRpbWVyXCI7XHJcbmltcG9ydCBtZW51IGZyb20gXCIuL21vZHVsZXMvbWVudVwiO1xyXG5pbXBvcnQgbW9kYWwgZnJvbSBcIi4vbW9kdWxlcy9tb2RhbFwiO1xyXG5pbXBvcnQgc21vdGhTY3JvbGwgZnJvbSBcIi4vbW9kdWxlcy9zbW90aFNjcm9sbFwiO1xyXG5pbXBvcnQgdGFicyBmcm9tIFwiLi9tb2R1bGVzL3RhYnNcIjtcclxuaW1wb3J0IG1haW5Gb3JtIGZyb20gXCIuL21vZHVsZXMvbWFpbkZvcm1cIjtcclxuXHJcbnRhYnMoKTtcclxubWVudSgpO1xyXG5zbW90aFNjcm9sbCgpO1xyXG5hY2NvcmRlb24oKTtcclxuY291bnRUaW1lcignMzEgbWFyY2ggMjAyMicpO1xyXG5tb2RhbCgpO1xyXG5tYWluRm9ybSgpO1xyXG5cclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhY3RzJykuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcxMDBweCc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///240\n")}},__webpack_exports__={};__webpack_modules__[240]()})();